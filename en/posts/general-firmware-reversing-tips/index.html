<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Preface
These notes were originally compiled years ago as a quick reference. They are somewhat fragmented and do not provide step-by-step procedures, but I continue to update them over time."><title>General Tips for Firmware Reverse Engineering&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="General Tips for Firmware Reverse Engineering" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/general-firmware-reversing-tips/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><style>
     
    .toc-wrapper {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 9999;
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 10px;
    }

     
    .toc-button {
        background-color: #fff;
        color: #333;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid #ddd;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .toc-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .toc-button svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }

     
    .toc-content-box {
        background: #fff;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 15px;
        width: 250px;
        max-height: 60vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        display: none;
         
        font-size: 0.9em;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.3s, transform 0.3s;
    }

    .toc-content-box.show {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }

    .toc-header {
        font-weight: bold;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 8px;
        margin-bottom: 8px;
        font-size: 1.1em;
    }

     
    #TableOfContents {
        text-align: left;
    }

    #TableOfContents ul,
    #TableOfContents ol {
        list-style: none;
        padding-left: 0;
        margin: 0;
    }

    #TableOfContents li {
        margin: 4px 0;
    }

    #TableOfContents ul ul,
    #TableOfContents ol ol {
        padding-left: 1em;
    }

    #TableOfContents a {
        text-decoration: none;
        color: #555;
        display: block;
        padding: 2px 0;
        transition: color 0.2s;
    }

    #TableOfContents a:hover {
        color: #007bff;
    }

     
    @media (prefers-color-scheme: dark) {
        .toc-button {
            background-color: #333;
            color: #ddd;
            border-color: #555;
        }

        .toc-content-box {
            background-color: #2a2a2a;
            border-color: #444;
            color: #ddd;
        }

        .toc-header {
            border-bottom-color: #444;
        }

        #TableOfContents a {
            color: #aaa;
        }

        #TableOfContents a:hover {
            color: #fff;
        }
    }
</style><div class="article-container"><section class="article header">
    <h1 class="article title">General Tips for Firmware Reverse Engineering</h1><p class="article date">Monday, August 15, 2022<span class="langs"><span class="lang">
                    <a href="/zh/posts/general-firmware-reversing-tips/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="preface">Preface</h2>
<p>These notes were originally compiled years ago as a quick reference. They are somewhat fragmented and do not provide step-by-step procedures, but I continue to update them over time.</p>
<p>In this context, &ldquo;firmware&rdquo; refers to raw dumps extracted from storage chips or vendor upgrade packages.</p>
<p><strong>Characteristics of reversing raw firmware:</strong></p>
<ul>
<li><strong>Acquisition difficulty:</strong> Firmware files can be hard to obtain.</li>
<li><strong>Limited resources:</strong> There are few public write-ups; you mostly rely on experience and exploration.</li>
<li><strong>No direction execution:</strong> You cannot run the firmware directly, making debugging difficult.</li>
<li><strong>Missing symbols:</strong> Most symbols are stripped; you often need to manually define code regions for disassembly.</li>
<li><strong>Low obfuscation:</strong> Code obfuscation is rarely applied.</li>
</ul>
<h2 id="firmware-categories">Firmware Categories</h2>
<p>Based on system architecture, firmware can be broadly categorized into <strong>SoC firmware</strong> and <strong>MCU firmware</strong>.</p>
<ul>
<li><strong>SoC Firmware:</strong> Typically consists of a processing unit plus peripherals. The processor&rsquo;s built-in BootROM loads a bootloader from external Flash; the data in that external Flash is what we consider the firmware. SoC devices typically use SPI NOR flash, NAND flash, or eMMC. SPI flash often stores the bootloader, while NAND flash stores the system kernel and filesystem. For the latter, extraction of the filesystem is key; for the former, the focus is on the boot process. Firmware in SPI flash is often composed of multiple distinct parts, so you cannot simply load a raw dump into IDA Pro and expect it to work.</li>
<li><strong>MCU Firmware:</strong> Usually monolithic or split into very few regions. For MCUs using only internal storage, the layout is generally Loader + Application. For MCUs with external storage, you will see an internal Loader + Application, and the external Flash is typically not heavily partitioned.</li>
</ul>
<h2 id="extracting-firmware">Extracting Firmware</h2>
<p>For NAND flash or other specialized storage media, extraction can require significant effort. Firmware from niche or proprietary MCUs can also be notoriously difficult to extract.</p>
<h2 id="finding-the-load-base-address">Finding the Load Base Address</h2>
<p>When reversing firmware, the first step is usually to determine the <strong>load base address</strong>. Once the correct base is established, IDA can automatically resolve many cross-references, including strings and jump tables (jpt).</p>
<p>(These are rough notes; ignore them if they don&rsquo;t apply to your specific case.)</p>
<p><strong>Methods to determine the load base address:</strong></p>
<ol>
<li><strong>Chip Datasheet:</strong> Use the memory map and boot-mode pin configuration to locate the base address.</li>
<li><strong>Public Code:</strong> Find open-source code for the chip (e.g., a compatible bootloader) and infer the base address from linker scripts or definitions.</li>
<li><strong>Previous-Stage Loader:</strong> Reverse the previous-stage loader to find where it loads the next stage (e.g., U-Boot environment variables or code often contain base address info).</li>
<li><strong>Vector Table (IVT):</strong> Interrupt vectors often contain absolute addresses; use them to make an educated guess.</li>
<li><strong>String References:</strong> If there is no interrupt vector table, look for pointers to strings that use absolute addresses.</li>
<li><strong>Brute-Force Analysis:</strong> Extract all strings, then find all potential reference sites in the code. The base address that yields the most valid cross-references is likely correct.</li>
<li><strong>Runtime Dump:</strong> If you have debug access (JTAG/SWD/UART), dump the memory at runtime and see where the firmware header resides.</li>
<li><strong>Pattern Matching:</strong> Consider &ldquo;round&rdquo; addresses like <code>0x????0000</code>. Compare the destination addresses of pointers/jumps with the distribution of strings in the file. If the lower bits match, the difference reveals the offset between the current base and the real base.</li>
<li><strong>IDA Trick:</strong> If the last 4 hex digits of an address offset match the last 4 hex digits of a generic pointer (DCD) value, then the high bits of that pointer value likely represent the base address&rsquo;s high bits.</li>
</ol>
<h2 id="analyzing-layout">Analyzing Layout</h2>
<p>Start with <code>hexdump</code> to visualize the data distribution, then use <code>binwalk</code> to identify the CPU instruction set architecture (ISA) and opcode distribution. If it remains unclear, use a hex editor to analyze byte-frequency distribution.</p>
<p>If the data appears compressed (e.g., high entropy), look for specific markers. For example, Lempel-Ziv-Welch (LZW) compression often produces many <code>0x9D</code> bytes. Check the bytes following <code>0x9D</code> to see if the stream matches the LZW structure. Reference: <a href="https://en.wikipedia.org/wiki/List_of_file_signatures"target="_blank" rel="noopener noreferrer">List of file signatures</a>.</p>
<p><strong>Other techniques:</strong></p>
<ul>
<li><strong>Endianness:</strong> Search for continuous strings sequences like <code>0123456789abcdefg</code>. Some systems (e.g., certain printers) use dual flash chips where one holds &ldquo;1267&rdquo; and the other &ldquo;3489&rdquo;. You may need to interleave and reconstruct the binary using the smallest byte block size.</li>
<li><strong>Magic Values:</strong> If source code is available, search for magic values from the source code within the firmware to reconstruct the layout.</li>
<li><strong>Differential Analysis:</strong> Compare firmware across different versions, or compare the same version with slightly different contents (control-variable method).</li>
<li><strong>Block Similarity:</strong> If you only have a single firmware sample, analyze block similarity to locate magic numbers and infer the system structure.</li>
</ul>
<h3 id="avoiding-duplicate-regions">Avoiding Duplicate Regions</h3>
<p>I developed a firmware security tool called <strong>UFA - Universal Firmware Analysis</strong> to help with this.</p>
<p><img loading="lazy"  src="./ufa.png"
        alt=""/></p>
<p>(Note: I implemented this feature in late 2020.)</p>
<p>Some firmware images contain redundant system copies (e.g., for A/B updates). With UFA (or other tools that visualize entropy), you can quickly identify duplicated regions and avoid analyzing the same code twice.</p>
<p><img loading="lazy"  src="./entropy2.png"
        alt=""/></p>
<h3 id="continuous-files--partially-compressed-files">Continuous Files &amp; Partially Compressed Files</h3>
<p>Partially compressed systems present significant challenges. In day-to-day reversing, you might extract a binary and try to analyze it directly. You see some strings and symbols, but IDA fails to analyze the code flow properly. An entropy graph might reveal that parts of the file are code, while others are compressed data, interspersed with constants (like SHA-512 constants).</p>
<p>Normal compressed data has a constantly high entropy (close to 1). In system firmware, it is unusual to see large sections of readable strings separated by large blocks of compressed data if it were a standard file system. By analyzing the previous-stage loader, you can often confirm if the binary is a <strong>continuous file</strong> with <strong>partial compression</strong>.</p>
<p><img loading="lazy"  src="./entropy3.png"
        alt=""/></p>
<h3 id="partial-encryption-vs-partial-compression">Partial Encryption vs. Partial Compression</h3>
<p>When partial encryption and partial compression are combined, analysis becomes extremely confusing.</p>
<p>IoT devices are often resource-constrained. To balance security and user experience (boot time), vendors may use <strong>partial encryption</strong>. For example, a SquashFS image might fail to unpack. An inexperienced reverser might assume the file is corrupted. A clearer analysis might reveal a decryption routine; however, even after decryption, unpacking might still fail. Since SquashFS is compressed by definition, &ldquo;partial encryption&rdquo; is harder to spot visually because both look like high-entropy noise.</p>
<p>However, partial encryption differs from full encryption:</p>
<ul>
<li><strong>Partial Compression/Encryption:</strong> Compressed data entropy usually fluctuates within a high range. Regions with fluctuations might indicate &ldquo;unencrypted leftovers&rdquo; or metadata inside an otherwise partially encrypted area. (See below)</li>
</ul>
<p><img loading="lazy"  src="./entropy4.png"
        alt=""/></p>
<ul>
<li><strong>Full Encryption:</strong> Fully encrypted data tends to have consistently high randomness, often appearing as a flat, high line on the entropy graph.</li>
</ul>
<p><img loading="lazy"  src="./entropy5.png"
        alt=""/></p>
<h2 id="identifying-functions">Identifying Functions</h2>
<p>If the base address is incorrect, IDA often cannot accurately detect code regions or function prologues. In such cases, you can try to blindly recover potential functions to get a foothold.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">remake_func</span><span class="p">(</span><span class="n">opcodes</span><span class="p">,</span> <span class="n">lastbytes</span><span class="p">,</span> <span class="n">end_ea</span> <span class="o">=</span> <span class="n">ida_ida</span><span class="o">.</span><span class="n">inf_get_max_ea</span><span class="p">()):</span>
</span></span><span class="line"><span class="cl">    <span class="n">ea</span> <span class="o">=</span> <span class="mh">0x0</span>
</span></span><span class="line"><span class="cl">    <span class="n">lastbytes_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastbytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">ea</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">ea</span> <span class="o">=</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">bin_search</span><span class="p">(</span><span class="n">ea</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end_ea</span><span class="p">,</span> <span class="n">opcodes</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">BIN_SEARCH_FORWARD</span> <span class="o">|</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">BIN_SEARCH_NOBREAK</span> <span class="o">|</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">BIN_SEARCH_NOSHOW</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">ea</span> <span class="o">==</span> <span class="n">BADADDR</span> <span class="p">:</span> <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;get_bytes: &#34;</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">ea</span><span class="o">-</span><span class="n">lastbytes_len</span><span class="p">),</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">get_bytes</span><span class="p">((</span><span class="n">ea</span><span class="o">-</span><span class="n">lastbytes_len</span><span class="p">),</span> <span class="n">lastbytes_len</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">ida_bytes</span><span class="o">.</span><span class="n">get_bytes</span><span class="p">((</span><span class="n">ea</span><span class="o">-</span><span class="n">lastbytes_len</span><span class="p">),</span> <span class="n">lastbytes_len</span><span class="p">)</span> <span class="o">==</span> <span class="n">lastbytes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">add_func</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">BADADDR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;0x</span><span class="si">{:x}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ea</span><span class="p">,</span> <span class="n">GetDisasm</span><span class="p">(</span><span class="n">ea</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Example usage: Searching for common function prologues/epilogues</span>
</span></span><span class="line"><span class="cl"><span class="n">remake_func</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x55\x89\xe5</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xc3</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mh">0xFF000000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">remake_func</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x55\x31\xC0</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xc3</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mh">0xFF000000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">remake_func</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x55\x89\xe5</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xc2\x04\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mh">0xFF000000</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="recovering-common-functions">Recovering Common Functions</h2>
<p>Proprietary MCU firmware rarely uses standard external libraries; most functionality is statically linked or implemented from scratch. You should first identify frequently used standard functions to build a map of the firmware&rsquo;s logic:</p>
<ul>
<li><code>memcpy</code></li>
<li><code>memset</code></li>
<li><code>memcmp</code></li>
<li><code>mmap</code></li>
<li><code>printf</code></li>
<li><code>strcpy</code></li>
<li><code>kfree</code> / <code>malloc</code></li>
</ul>
<p>For firmware based on open-source projects, you can use source-based signatures.</p>
<p><strong>Script to find the most-referenced functions:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">idaapi</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">funcs</span> <span class="o">=</span> <span class="n">Functions</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span> <span class="o">=</span> <span class="n">Name</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">func_xref_amount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">XrefsTo</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">func_xref_amount</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func_xref_amount</span><span class="p">)</span>
</span></span></code></pre></div><p>For open-source MCU firmware, compile your own build using the same toolchain and version if possible. Generate a MAP file or symbols, use FLIRT to create signatures, and then match them against the target firmware to recover function names.</p>
<h3 id="finding-functions-with-string-references">Finding Functions with String References</h3>
<p>For firmware where the base address is not aligned to a standard boundary (like <code>0x1000</code>), guessing the base is difficult. A useful trick involves inspecting string global variables.</p>
<p>First, look at the list of strings in IDA and note the sequence of their offsets.</p>
<p><img loading="lazy"  src="./strings.png"
        alt=""/></p>
<p>On x86 architectures, arguments for static variables are often pushed onto the stack. Searching for <code>push</code> instructions is often more effective than searching for <code>mov</code>. In IDA, perform a binary search for the opcode <code>push 0x...</code> (or search for the immediate values). Filter for values ending with specific patterns derived from the string offsets (e.g., <code>0x********62</code>, <code>0x********97</code>).</p>
<p>As shown below, if the regularity of the immediate values in the code matches the distance between the strings, the correct base address becomes obvious.</p>
<p><img loading="lazy"  src="./push.png"
        alt=""/></p>
<p><strong>Base calculation example:</strong>
<code>0xFEFA5762</code> (Immediate Value) - <code>0x22F62</code> (String Offset) = <code>0xFEF82800</code> (Base Address)</p>
<h2 id="fixing-function-cross-references">Fixing Function Cross-References</h2>
<p>If you cannot identify the caller of a function, it may be referenced via a jump table. Globally search for immediate values equal to the function&rsquo;s address.</p>
<ul>
<li><strong>Note:</strong> Sometimes addresses are stored as relative offsets; you must subtract the base address to find the stored value.</li>
<li><strong>Split Addresses:</strong> Sometimes a 32-bit address is constructed from high 16 bits and low 16 bits:</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">MOV</span> <span class="no">Rx</span><span class="p">,</span> <span class="c1">#HighAddr
</span></span></span><span class="line"><span class="cl"><span class="nf">MOVT</span> <span class="no">Rx</span><span class="p">,</span> <span class="c1">#LowAddr
</span></span></span></code></pre></div><h2 id="niche-architectures">Niche Architectures</h2>
<p>IDA Pro is excellent at disassembling machine code and generating call graphs for common architectures. However, for niche architectures like NEC V850, you often need to manually identify function entry points. Many cross-references will not be automatically recognized and must be created manually.</p>
<p>Another challenge is chip-specific register layouts: RAM, peripheral buses, interface registers, interrupt controllers, etc.</p>
<ul>
<li><strong>Solution:</strong> Consult the datasheet. If the datasheet is not public, look for Board Support Packages (BSPs) or scatter files code for similar chips.</li>
<li><strong>IDA Config:</strong> Add platform-specific configurations to IDA Pro&rsquo;s <code>cfg</code> files (address map, register names, etc.) to aid analysis.</li>
</ul>
<h2 id="reversing-by-comparing-with-source">Reversing by Comparing with Source</h2>
<p>If you cannot understand a specific piece of code, find an open-source project with similar functionality. Compile it for the same platform, load the result into IDA Pro, and compare the assembly against your target. This comparative analysis often clarifies the code&rsquo;s intent.</p>
<h2 id="emulation">Emulation</h2>
<p>If you face complex obfuscated or mathematical code but only need the input/output behavior, emulate it using <strong>Unicorn Engine</strong>. It supports common architectures like ARM, MIPS, and PPC, allowing you to execute the code slice in isolation.</p>
<h2 id="reversing-specific-features">Reversing Specific Features</h2>
<p>Crypto libraries often rely on specific constant tables (S-boxes, initialization vectors). By searching for these constants, you can identify the algorithms used (AES, SHA, CRC) and locate the functions that use them. Encryption, hashing, and checksum routines are critical checkpoints commonly found during boot, firmware upgrade, and communication phases.</p>
<ul>
<li><strong>Tools:</strong> Use the <strong>FindCrypt</strong> plugin to quickly locate these constants.</li>
<li><strong>Protocols:</strong> For SD/SATA protocols, search for specific Command (CMD) values.</li>
<li><strong>Vehicle Networks:</strong> For CAN bus analysis, search for the memory-mapped addresses of CAN registers.</li>
</ul>
<h2 id="ida-pro-problems-tips">IDA Pro &ldquo;Problems&rdquo; Tips</h2>
<p>In IDA Pro, navigate to <strong>View &gt; Open subviews &gt; Problems</strong>, and look for:</p>
<ul>
<li><strong>NONAME</strong></li>
<li><strong>BOUNDS</strong></li>
</ul>
<p>These items often indicate an instruction using an immediate value that points outside the defined internal segments. These values could be:</p>
<ol>
<li>Peripheral register addresses.</li>
<li>Valid memory addresses if the firmware base address were set correctly.</li>
<li>Addresses belonging to an <strong>external binary</strong> (common in bootloaders or multi-stage firmwares).</li>
</ol>
<p><strong>Tip:</strong> If Firmware A&rsquo;s base is unknown, but you see references to addresses that look like they belong to Firmware A (whose range you know from a different stage), references in Firmware B can help you calculate Firmware A&rsquo;s base.</p>
<h3 id="case-study">Case Study</h3>
<p>Consider an x86 firmware with an unknown base.</p>
<ol>
<li>Check the <strong>Problems</strong> view and filter for <strong>BOUNDS</strong>.</li>
<li>You see many <code>call</code> instructions using relative addressing (e.g., <code>near ptr</code>).</li>
<li>Address <code>0x7A10A</code> appears. If the file size is smaller than <code>0x40000</code>, <code>0x7A10A</code> is clearly invalid as a raw offset‚Äîit implies a base address is missing.</li>
</ol>
<p><img loading="lazy"  src="./problem_bounds_relative.png"
        alt=""/></p>
<ol start="4">
<li>Clicking one instance reveals that <code>0xFEF84DE0</code> is passed as an argument to the function at <code>0x7A10A</code>. This is likely a global variable address, not a register.</li>
</ol>
<p><img loading="lazy"  src="./problem_bounds_relative_case.png"
        alt=""/></p>
<ol start="5">
<li>Using the <strong>String Reference</strong> trick (described earlier), you determine the base is <code>0xFEF82800</code>.</li>
<li>After rebasing, IDA identifies more functions.</li>
<li>The address <code>0x7A10A</code> updates to <code>0xFEFFC90A</code>. If this is still outside the file&rsquo;s mapped memory, it likely points to an external binary (e.g., a shared library or common boot code).</li>
<li>If you know from another binary that <code>printf</code> is at <code>0xFEFFC90A</code>, you can map that external binary into your current IDA database.</li>
</ol>
<p><strong>Adding a Segment in IDA:</strong>
Be careful; the UI can be tricky.</p>
<ol>
<li>Press <code>Shift+F7</code> to open the <strong>Segments</strong> window.</li>
<li>Right-click -&gt; <strong>Add segment</strong>.</li>
<li>Set the <strong>Start address</strong> to the external binary&rsquo;s base.</li>
</ol>
<p><img loading="lazy"  src="./add_segment.png"
        alt=""/></p>
<ol start="4">
<li>Verify there are no overlaps with existing segments.</li>
</ol>
<p><img loading="lazy"  src="./segment.png"
        alt=""/></p>
<ol start="5">
<li>Load the external binary: <strong>File -&gt; Load file -&gt; Additional binary file&hellip;</strong></li>
<li>Set the <strong>Loading offset</strong> to the base address of the new segment.</li>
</ol>
<p><img loading="lazy"  src="./load_bin.png"
        alt=""/></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="category" href=/en/categories/reverse-engineering/>Reverse Engineering</a><a class="tag" href=/en/tags/firmware-reverse-engineering/>Firmware Reverse Engineering</a><a class="tag" href=/en/tags/mcu/>MCU</a><a class="tag" href=/en/tags/bootloader/>Bootloader</a></section>
</div>

<div class="toc-wrapper">
    <div class="toc-content-box" id="toc-content-box">
        <div class="toc-header">Table of Contents</div>
        <nav id="TableOfContents">
  <ol>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#firmware-categories">Firmware Categories</a></li>
    <li><a href="#extracting-firmware">Extracting Firmware</a></li>
    <li><a href="#finding-the-load-base-address">Finding the Load Base Address</a></li>
    <li><a href="#analyzing-layout">Analyzing Layout</a>
      <ol>
        <li><a href="#avoiding-duplicate-regions">Avoiding Duplicate Regions</a></li>
        <li><a href="#continuous-files--partially-compressed-files">Continuous Files &amp; Partially Compressed Files</a></li>
        <li><a href="#partial-encryption-vs-partial-compression">Partial Encryption vs. Partial Compression</a></li>
      </ol>
    </li>
    <li><a href="#identifying-functions">Identifying Functions</a></li>
    <li><a href="#recovering-common-functions">Recovering Common Functions</a>
      <ol>
        <li><a href="#finding-functions-with-string-references">Finding Functions with String References</a></li>
      </ol>
    </li>
    <li><a href="#fixing-function-cross-references">Fixing Function Cross-References</a></li>
    <li><a href="#niche-architectures">Niche Architectures</a></li>
    <li><a href="#reversing-by-comparing-with-source">Reversing by Comparing with Source</a></li>
    <li><a href="#emulation">Emulation</a></li>
    <li><a href="#reversing-specific-features">Reversing Specific Features</a></li>
    <li><a href="#ida-pro-problems-tips">IDA Pro &ldquo;Problems&rdquo; Tips</a>
      <ol>
        <li><a href="#case-study">Case Study</a></li>
      </ol>
    </li>
  </ol>
</nav>
    </div>
    <div class="toc-button" onclick="toggleTOC()" title="">
        
        <svg viewBox="0 0 24 24">
            <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path>
        </svg>
    </div>
</div>

<script>
    function toggleTOC() {
        const tocBox = document.getElementById('toc-content-box');
        if (tocBox.classList.contains('show')) {
            tocBox.classList.remove('show');
            
            
            
            
            
            setTimeout(() => {
                tocBox.style.display = 'none';
            }, 300); 
        } else {
            tocBox.style.display = 'block';
            
            void tocBox.offsetWidth;
            tocBox.classList.add('show');
        }
    }

    
    document.addEventListener('click', function (event) {
        const wrapper = document.querySelector('.toc-wrapper');
        const tocBox = document.getElementById('toc-content-box');
        if (wrapper && !wrapper.contains(event.target) && tocBox.classList.contains('show')) {
            toggleTOC();
        }
    });
</script><div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/qnx7-password-hash-analysis-and-hashcat-module/"><span class="iconfont icon-article"></span>QNX 7 Password Hash Analysis and Writing a Hashcat Module</a></p><p><a class="link" href="/en/posts/bypass-jvmti-encryption-protection/"><span class="iconfont icon-article"></span>Bypassing JVMTI-Based Encryption Protection</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>