<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Preface
The SD card (Secure Digital Memory Card) is a NAND flash-based storage medium designed as a successor to the MMC (Multimedia Card). It is commonly found in multimedia players, cameras, and smartphones, and has since been widely adopted in IoT devices and automotive electronics. Physically, SD cards are categorized into three sizes: SD, miniSD, and microSD."><title>Firmware Extraction Series - SD Card Unlock&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series - SD Card Unlock" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-sd-card-unlock/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><style>
     
    .toc-wrapper {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 9999;
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 10px;
    }

     
    .toc-button {
        background-color: #fff;
        color: #333;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid #ddd;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .toc-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .toc-button svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }

     
    .toc-content-box {
        background: #fff;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 15px;
        width: 250px;
        max-height: 60vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        display: none;
         
        font-size: 0.9em;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.3s, transform 0.3s;
    }

    .toc-content-box.show {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }

    .toc-header {
        font-weight: bold;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 8px;
        margin-bottom: 8px;
        font-size: 1.1em;
    }

     
    #TableOfContents {
        text-align: left;
    }

    #TableOfContents ul,
    #TableOfContents ol {
        list-style: none;
        padding-left: 0;
        margin: 0;
    }

    #TableOfContents li {
        margin: 4px 0;
    }

    #TableOfContents ul ul,
    #TableOfContents ol ol {
        padding-left: 1em;
    }

    #TableOfContents a {
        text-decoration: none;
        color: #555;
        display: block;
        padding: 2px 0;
        transition: color 0.2s;
    }

    #TableOfContents a:hover {
        color: #007bff;
    }

     
    @media (prefers-color-scheme: dark) {
        .toc-button {
            background-color: #333;
            color: #ddd;
            border-color: #555;
        }

        .toc-content-box {
            background-color: #2a2a2a;
            border-color: #444;
            color: #ddd;
        }

        .toc-header {
            border-bottom-color: #444;
        }

        #TableOfContents a {
            color: #aaa;
        }

        #TableOfContents a:hover {
            color: #fff;
        }
    }
</style><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series - SD Card Unlock</h1><p class="article date">Thursday, October 18, 2018<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-sd-card-unlock/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="preface">Preface</h2>
<p>The SD card (Secure Digital Memory Card) is a NAND flash-based storage medium designed as a successor to the MMC (Multimedia Card). It is commonly found in multimedia players, cameras, and smartphones, and has since been widely adopted in IoT devices and automotive electronics. Physically, SD cards are categorized into three sizes: SD, miniSD, and microSD.</p>
<p><img loading="lazy"  src="./sd_size.png"
        alt="sd_size"/></p>
<p>There are two common speed class markings: the ‚Äústandard‚Äù speed class and the UHS speed class. Each corresponds to a different bus interface mode. The SD Association has also introduced the Video Speed Class, which utilizes the UHS bus. SD card capacities are also standardized, ranging from SDSC (Standard Capacity) to SDUC (Ultra Capacity).</p>
<p><img loading="lazy"  src="./Micro-SD-speeds.png"
        alt="Micro-SD-speeds"/>
<img loading="lazy"  src="./bus_speed_img.jpg"
        alt="bus_speed_img"/></p>
<p>SD card parameters can often be seen on the label sticker or silkscreen.</p>
<p><img loading="lazy"  src="./sd_sticker.png"
        alt="sd_sticker"/></p>
<p>microSD was originally known as T-Flash (TransFlash). SD slots are backward compatible with MMC cards. Additionally, eMMC chips can be wired to an SD slot for interfacing.</p>
<p><img loading="lazy"  src="./sd_emmc.png"
        alt="sd_emmc"/></p>
<p>This post is based on the SD Physical Layer Simplified Specification, Version 6, and focuses on the unlock mechanism.</p>
<p>SDIO (Secure Digital Input Output) is an extension of the SD standard derived from the SD Physical Layer specification. Beyond SDIO memory cards, the specification supports SDIO peripheral devices such as Wi-Fi modules, GPS modules, and CMOS sensors.</p>
<h2 id="io-information">I/O Information</h2>
<p>Below is a pin comparison between MMC and SD cards.</p>
<p><img loading="lazy"  src="./pin_compare.gif"
        alt="pin_compare"/></p>
<p>These pins serve different functions depending on the bus protocol and transfer mode. This post focuses primarily on the SD-mode specification. The pin types are defined as follows:</p>
<ul>
<li>S - Power Supply</li>
<li>I - Input</li>
<li>O - Output using Pull Push Drivers</li>
<li>PP - I/O using Pull Push Drivers</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Pin #</th>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>CD/DAT3</td>
          <td>I/O/PP</td>
          <td>Card Detect/Data Line [Bit3]</td>
      </tr>
      <tr>
          <td>2</td>
          <td>CMD</td>
          <td>I/O/PP</td>
          <td>Command/Response</td>
      </tr>
      <tr>
          <td>3</td>
          <td>VSS1</td>
          <td>S</td>
          <td>Supply voltage ground</td>
      </tr>
      <tr>
          <td>4</td>
          <td>VDD</td>
          <td>S</td>
          <td>Supply voltage</td>
      </tr>
      <tr>
          <td>5</td>
          <td>CLK</td>
          <td>I</td>
          <td>Clock</td>
      </tr>
      <tr>
          <td>6</td>
          <td>VSS2</td>
          <td>S</td>
          <td>Supply voltage ground</td>
      </tr>
      <tr>
          <td>7</td>
          <td>DAT0</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit0]</td>
      </tr>
      <tr>
          <td>8</td>
          <td>DAT1</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit1]</td>
      </tr>
      <tr>
          <td>9</td>
          <td>DAT2</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit2]</td>
      </tr>
  </tbody>
</table>
<p>Below is the SD card under analysis: an SDSC card (max 2GB), labeled ‚ÄúM2B9 2GB Made in Japan‚Äù. These markings yielded no search results.</p>
<p><img loading="lazy"  src="./SD_card_internal.jpg"
        alt="SD_card_internal"/></p>
<p>The SD controller chip is marked ‚Äú56X31B002 AC00145R‚Äù, which also returned no search results.
However, the underlying memory chip features a Micron logo. Using the <a href="https://www.micron.com/decoder"target="_blank" rel="noopener noreferrer">FBGA &amp; Component Marking Decoder</a>, I identified it as an SLC NAND Flash in a VBGA100 package. The official database seems incomplete, listing only a 16GB version.</p>
<p><img loading="lazy"  src="./SD_card_internal2.jpg"
        alt="SD_card_internal2"/></p>
<h2 id="registers">Registers</h2>
<p>Registers such as OCR, CID, CSD, and SCR contain card-specific information. RCA and DSR store configuration parameters, while SSR and CSR convey status information.
The specification authors seem partial to three-letter abbreviations; when three letters suffice, the ‚ÄúR‚Äù (for Register) is often omitted.</p>
<table>
  <thead>
      <tr>
          <th>Name</th>
          <th>length(bit)</th>
          <th>Description</th>
          <th>Optional</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>CID</td>
          <td>128</td>
          <td>Card Identification Data, includes Manufacturer ID, OEM ID, Product Name, Product Revision, Manufacturing Date, and checksum</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>RCA</td>
          <td>16</td>
          <td>Relative Card Address, used for addressing; default 0x0000; not available in SPI mode</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>DSR</td>
          <td>16</td>
          <td>Driver Stage Register, used to improve bus performance</td>
          <td>Optional</td>
      </tr>
      <tr>
          <td>CSD</td>
          <td>128</td>
          <td>Card Special Data, complex; includes operating conditions such as error types, maximum data access time, speed, DSR availability, etc.</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>SCR</td>
          <td>64</td>
          <td>SD Configuration Register, includes supported features and spec version</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>OCR</td>
          <td>32</td>
          <td>Operation Condition Register, carries current power information</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>SSR</td>
          <td>512</td>
          <td>SD Status Register, carries current SD card characteristics and application-specific status info such as bus width, security mode, card type, speed, etc.</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>CSR</td>
          <td>32</td>
          <td>Card Status Register, carries the status when executing commands (reflected in responses), such as lock state and error info</td>
          <td>Required</td>
      </tr>
  </tbody>
</table>
<h2 id="architecture">Architecture</h2>
<p>The card contains a power-on detection circuit connected to both the host interface and the storage-area interface. Each pin connects to the card controller, and the controller operates on the storage area via the storage interface.</p>
<p><img loading="lazy"  src="./architecture.png"
        alt="architecture"/></p>
<h3 id="sdio">SDIO</h3>
<p>The SDIO specification defines two types of cards: low-speed and high-speed. Three underlying bus modes are supported:</p>
<ul>
<li><strong>SPI bus mode</strong></li>
<li><strong>1-bit SD bus mode</strong>: Command and data lines are strictly separated.</li>
<li><strong>4-bit SD bus mode</strong>: Supported by high-speed cards. Commands utilize a dedicated channel, while four other lines transfer data. This is the default configuration for SD mode.</li>
</ul>
<h2 id="sd-bus-protocol">SD Bus Protocol</h2>
<p>SD bus communication relies primarily on the CMD (Command) and DAT (Data) lines. CMD and DAT signals are transmitted in parallel on separate channels. The command channel is bidirectional: CMD tokens are sent by the host, and Responses are returned by the SD card. A Response is only generated for valid commands.</p>
<p><img loading="lazy"  src="./sd_protocal.png"
        alt="sd_protocal"/></p>
<p>The SD protocol specifies block-based read/write operations. The data block transmission follows the command sequence. Each data block is terminated with CRC bits. An operation is concluded by sending a stop command.</p>
<p><img loading="lazy"  src="./sd_protocal_r.png"
        alt="sd_protocal_r"/></p>
<p>The write process includes a busy signal.</p>
<p><img loading="lazy"  src="./sd_protocal_w.png"
        alt="sd_protocal_w"/></p>
<h3 id="cmd-format">CMD Format</h3>
<p>The Command Token length is 48 bits. The start bit is 0. The transmission bit is 1, indicating data from the host. Content carries the command, address information, and parameters. It ends with a 7-bit CRC (Cyclic Redundancy Check), and the end bit is 0. Because of this property, the first byte of a Response is 0x40 smaller than the first byte of a CMD.</p>
<p><img loading="lazy"  src="./cmd_format.png"
        alt="cmd_format"/></p>
<p>There are four response token scenarios. Depending on the scenario, different lengths are used: 48-bit (R1, R3, R6) and 136-bit (R2). The transmission bit is 0, indicating data from the SD card.</p>
<p><img loading="lazy"  src="./response_format.png"
        alt="response_format"/></p>
<h3 id="data-packet-format">Data Packet Format</h3>
<p>In normal mode, data is transmitted via DAT[0-3]. Like CMD, it has a start bit 0, an end bit 1, and CRC. The default bus width is 1-bit.</p>
<p><img loading="lazy"  src="./data_packet_format.png"
        alt="data_packet_format"/></p>
<h3 id="crc7">CRC7</h3>
<p>SD cards use the CRC7/MMC algorithm for CMD checking. The formula is:</p>
<p><img loading="lazy"  src="./crc7_calc.png"
        alt="crc7_calc"/></p>
<p>Convert the polynomial to binary G(x):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">10001001
</span></span></code></pre></div><p>Append (divisor-1) bits (i.e., 7) to the data frame M(x), then perform modulo-2 division: divide the data frame by 10001001 to obtain the CRC.</p>
<p><img loading="lazy"  src="./crc7.png"
        alt="crc7"/></p>
<h3 id="crc16">CRC16</h3>
<p>SD cards use CRC-16/CCITT-XMODEM for Data checking. In wide-bus mode, each line computes CRC independently. The formula is:</p>
<p><img loading="lazy"  src="./crc16_calc.png"
        alt="crc16_calc"/></p>
<p>Convert the polynomial to binary G(x); the 16th bit exceeds the length and is ignored:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">0001000000100001
</span></span></code></pre></div><p><img loading="lazy"  src="./crc16.png"
        alt="crc16"/></p>
<h2 id="response-type">Response Type</h2>
<p>There are five types of SD card responses; SDIO supports additional response types R4 and R5. Except for R3, response packets end with CRC.</p>
<ul>
<li>R1 Normal response; may carry a busy signal (R1b)</li>
<li>R2 CID/CSD response</li>
<li>R3 OCR response</li>
<li>R6 RCA response</li>
<li>R7 Card interface condition response</li>
</ul>
<h3 id="formats-for-different-response-types">Formats for different response types</h3>
<p>The parameter field of R1 is 32 bits and corresponds to card status. Due to version iteration, the spec doesn‚Äôt explicitly call it CSR, and the CSR register was defined later. R2 directly returns CID or CSD data. R3 returns OCR data.</p>
<p><img loading="lazy"  src="./response_r1.png"
        alt="response_r1"/>
<img loading="lazy"  src="./response_r2.png"
        alt="response_r2"/>
<img loading="lazy"  src="./response_r3.png"
        alt="response_r3"/>
<img loading="lazy"  src="./response_r6.png"
        alt="response_r6"/>
<img loading="lazy"  src="./response_r7.png"
        alt="response_r7"/></p>
<h2 id="function-mode">Function mode</h2>
<p>There are two operating modes for SD cards; by default the card is inactive:</p>
<ul>
<li>card indentification mode</li>
<li>data transfer mode</li>
</ul>
<p>Under UHS-II and SD mode, the card identification mode differs.</p>
<h2 id="command">Command</h2>
<p>Commands are mainly of two types‚Äîbroadcast and addressed. More specifically, there are four categories:</p>
<ul>
<li>broadcast commands (bc), no response</li>
<li>broadcast commands with response (bcr) (Note: No open drain on SD card)</li>
<li>addressed (point-to-point) commands (ac), no data transfer on DAT lines</li>
<li>addressed (point-to-point) data transfer commands (adtc), data transfer on DAT lines</li>
</ul>
<p>CMD5 and CMD52-54 are SDIO-specific.</p>
<p>Most Significant Bit (MSB) is transmitted first; Least Significant Bit (LSB) is transmitted last.</p>
<p><img loading="lazy"  src="./command_format.png"
        alt="command_format"/></p>
<p>Commands are grouped into classes:</p>
<table>
  <thead>
      <tr>
          <th>Class #</th>
          <th>Name</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>Basic Commands</td>
      </tr>
      <tr>
          <td>1</td>
          <td>Command and Queue Function Commands</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Block Oriented Read Commands</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Reserved</td>
      </tr>
      <tr>
          <td>4</td>
          <td>Block Oriented Write Commands</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Erase Commands</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Block Oriented Write Protection Commands</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Lock Card</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Application Specific Commands</td>
      </tr>
      <tr>
          <td>9</td>
          <td>I/O Mode Commands</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Switch Function Commands</td>
      </tr>
      <tr>
          <td>11</td>
          <td>Function Extension Commands</td>
      </tr>
  </tbody>
</table>
<p>Class 7 contains three commands related to card locking. <code>CMD16</code> sets the block length (often used before setting a password). <code>CMD42</code> performs the actual lock/unlock operations. Even when locked, a card responds to Class 0 commands.</p>
<p><img loading="lazy"  src="./card_lock_class.png"
        alt="card_lock_class"/></p>
<p>For SDSC cards, <code>SET_BLOCK_LEN</code> can be used to specify the data block length. For SDHC and SDXC cards, the block length is fixed at 512 bytes.</p>
<h2 id="application-specific-commands">Application-Specific Commands</h2>
<p>Application-Specific Commands extend Commands. CMD55 is the condition to trigger ACMD; ACMD41 is CMD55 followed by CMD41.</p>
<p>ACMD41 is the initialization command and sets HCS (Host Capacity Support), determining SD card type, power control, and voltage levels. ACMD6 sets the bus width, choosing 1-bit or 4-bit data transfer. Only unlocked cards in transfer state can use ACMD6.</p>
<h2 id="status-information">Status Information</h2>
<p>SD card status information can be seen in R1-type responses, e.g., CMD13. SD cards have three kinds of status information:</p>
<ul>
<li>SD Status</li>
<li>Card Status</li>
<li>Task Status</li>
</ul>
<p>Below are the type definitions for each bit:</p>
<p>E - Error bit
S - Status bit
R - Detected and set for the actual command response
X - Detected and set during command execution. The host can obtain status info from command responses</p>
<p>And the clear conditions for status bits:</p>
<p>Status bits may be cleared under the following conditions:</p>
<p>A - According to the current card status.
B - Always related to the previous command. Cleared by receiving a new command.
C - Cleared by read.</p>
<p>R1 responses carry the 32-bit card status information, which is derived from the CSR. The table below defines each bit (reserved bits omitted).</p>
<table>
  <thead>
      <tr>
          <th>Bits</th>
          <th>Identifier</th>
          <th>Type</th>
          <th>Value</th>
          <th>Description</th>
          <th>Clear Condition</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>31</td>
          <td>OUT_OF_RANGE</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The command&rsquo;s argument was out of the allowed range for this card.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>30</td>
          <td>ADDRESS_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>A misaligned address which did not match the block length was used in the command.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>29</td>
          <td>BLOCK_LEN_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The transferred block length is not allowed for this card, or the number of transferred bytes does not match the block length.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>28</td>
          <td>ERASE_SEQ_ERROR</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>An error in the sequence of erasecommands occurred.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>27</td>
          <td>ERASE_PARAM</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>An invalid selection of write-blocksfor erase occurred.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>26</td>
          <td>WP_VIOLATION</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no protected<br/>&lsquo;1&rsquo;= protected</td>
          <td>Set when the host attempts to writeto a protected block or to the temporary or permanent write protected card.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>25</td>
          <td>CARD_IS_LOCKED</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= card unlocked<br/>&lsquo;1&rsquo;= card locked</td>
          <td>When set, signals that the card is locked by the host.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>24</td>
          <td>LOCK_UNLOCK_FAILED</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Set when a sequence or passworderror has been detected in lock/unlock card command.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>23</td>
          <td>COM_CRC_ERROR</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The CRC check of the previous command failed.</td>
          <td>B</td>
      </tr>
      <tr>
          <td>22</td>
          <td>ILLEGAL_COMMAND</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Command not legal for the cardstate</td>
          <td>B</td>
      </tr>
      <tr>
          <td>21</td>
          <td>CARD_ECC_FAILED</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Card internal ECC was applied butfailed to correct the data.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>20</td>
          <td>CC_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Internal card controller error.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>19</td>
          <td>ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>A general or an unknown error occurred during the operation.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>16</td>
          <td>CSD_OVERWRITE</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Can be either one of the following errors: <br/>- The read only section of the CSD does not match the card content. <br/>- An attempt to reverse the copy (set as original) or permanent WP (unprotected) bits was made.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>15</td>
          <td>WP_ERASE_SKIP</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no protected<br/>&lsquo;1&rsquo;= protected</td>
          <td>Set when only partial address space was erased due to existing write protected blocks or the temporary or permanent write protected card was erased.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>14</td>
          <td>CARD_ECC_DISABLED</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= enabled<br/>&lsquo;1&rsquo;= disabled</td>
          <td>The command has been executed without using the internal ECC.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>13</td>
          <td>ERASE_RESET</td>
          <td>S R</td>
          <td>&lsquo;0&rsquo;= cleared<br/>&lsquo;1&rsquo;= set</td>
          <td>An erase sequence was cleared before executing because an out of erase sequence command was received.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>12:9</td>
          <td>CURRENT_STATE</td>
          <td>S X</td>
          <td>0 = idle<br/>1 = ready<br/>2 = ident<br/>3 = stby<br/>4 = tran<br/>5 = data<br/>6 = rcv<br/>7 = prg<br/>8 = dis<br/>9-14 = reserved<br/>15 = reserved for<br/>I/O mode</td>
          <td>The state of the card when receiving the command. If the command execution causes a state change, it will be visible to the host in the response to the next command.<br/> The four bits are interpreted as a binary coded number between 0 and 15.</td>
          <td>B</td>
      </tr>
      <tr>
          <td>8</td>
          <td>READY_FOR_DATA</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= not ready<br/>&lsquo;1&rsquo;= ready</td>
          <td>Corresponds to buffer empty signaling on the bus.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>6</td>
          <td>FX_EVENT</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= No event<br/>&lsquo;1&rsquo;= Event invoked</td>
          <td>Extension Functions may set this bit to get host to deal with events.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>5</td>
          <td>APP_CMD</td>
          <td>S R</td>
          <td>&lsquo;0&rsquo;= enabled<br/>&lsquo;1&rsquo;= disabled</td>
          <td>The card will expect ACMD, or an indication that the command has been interpreted as ACMD.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>3</td>
          <td>AKE_SEQ_ERROR(SD Memory Card app. spec.)</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Error in the sequence of the authentication process.</td>
          <td>C</td>
      </tr>
  </tbody>
</table>
<p><code>12:9</code> is 4 bits long. Converting to decimal corresponds to the card‚Äôs operating stage:</p>
<p><img loading="lazy"  src="./state_mode.png"
        alt="state_mode"/></p>
<h2 id="sd-protocol-sniff">SD Protocol Sniff</h2>
<p>Length matching is a PCB design term, commonly used for high-speed I/O such as DDR. When using fly-wires, try to keep equal lengths and control the distance between the clock line and other signal lines‚Äîthis is also an SD card vendor requirement for PCB design.</p>
<p><img loading="lazy"  src="./wiring.jpg"
        alt="wiring"/></p>
<p>In practice, standard SD &ldquo;High Speed&rdquo; mode operates at 25MHz/50MHz. While length matching is less critical at these speeds than for UHS modes, signal integrity remains important. The crucial factor here is the logic analyzer&rsquo;s sampling rate. My initial attempts with a 100MHz sampling rate produced garbage data; switching to an LA5016 at 500MHz resolved the issue.</p>
<p><img loading="lazy"  src="./LA5016.jpg"
        alt="LA5016"/></p>
<p>The selected logic level must match the device voltage. Configure the analyzer for SDIO and trigger on the rising edge of the clock signal. This ensures accurate logic level capture. As shown below, the data line state is <code>0</code> at the rising clock edge.</p>
<p><img loading="lazy"  src="./rising_edge.png"
        alt="rising_edge"/></p>
<h2 id="sd-unlock">SD Unlock</h2>
<p>The unlock session remains valid only for the current power cycle; the SD card will revert to a locked state upon the next power-up. The unlock sequence begins with <code>CMD7</code> to select the card. If the Force Erase Password (FEP) bit is set, the COP (Card Ownership Protection) must be cleared. Next, <code>CMD16</code> sets the necessary block length: 1 byte for operation mode + 1 byte for password length + the actual password length. Finally, <code>CMD42</code> is issued to perform the unlock.</p>
<p><img loading="lazy"  src="./unlock_operations.png"
        alt="unlock_operations"/></p>
<h3 id="cmd-42">CMD 42</h3>
<h3 id="cmd-42-1">CMD 42</h3>
<p><code>CMD42</code> manages card locking and unlocking. The feature has two versions: V1.0 and V2.0. Unlocking can be performed via two methods: Force Erase Password (FEP) or standard password authentication. FEP uses a non-volatile register available only on cards supporting COP (Card Ownership Protection). COP was introduced in SD Specification 6.0, and such cards remain rare in the market.</p>
<p>From the CMD format, <code>01</code> indicates a CMD request, <code>101010</code> represents 42, so the first byte of CMD42 should be <code>01101010</code>, i.e. <code>6A</code>.
The first 4 bits of CMD42‚Äôs argument should be 0. The corresponding CSR status bit-25 should change from 1 to 0, and bit-24 should be 0.</p>
<p><img loading="lazy"  src="./unlock_parameters.png"
        alt="unlock_parameters"/></p>
<p>By decoding the communication between the host and the SD card with a logic analyzer, I obtained the following frame. The Command Index, Arguments, and CRC7 all match the definitions above.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">6A 00 00 00 00 51
</span></span></code></pre></div><p>The last byte <code>51</code> can be validated via CRC7.</p>
<p>The target device studied in this post is relatively old and does not support COP. In the lock/unlock bit, <code>0</code> indicates unlock and <code>1</code> indicates lock. Since we use CMD42, the operation parameter is <code>00000000</code>, i.e. <code>CMD42[00h]</code>.</p>
<p>For the Data portion of CMD42: the first byte describes the operation. The first three bits are reserved and are typically set to 0. The fourth bit indicates the COP feature. During unlock, the remaining four bits should all be 0. The second byte is the password length field, 8 bits wide, in bytes. Therefore the maximum password length is 128 bytes. Here the password length is 16 bytes. Starting from the third byte is the password data, and finally a 16-bit CRC is appended.</p>
<p><img loading="lazy"  src="./password.png"
        alt="password"/></p>
<p>The address in <code>CMD7</code> is dynamically assigned (Random Card Address):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">47 4B 47 00 00 6F
</span></span><span class="line"><span class="cl">[47:41] 01000111  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 01001011  RCA 4B
</span></span><span class="line"><span class="cl">[31:24] 01000111  RCA 47
</span></span><span class="line"><span class="cl">[23:16] 00000000  stuff bits
</span></span><span class="line"><span class="cl">[15:8]  00000000
</span></span><span class="line"><span class="cl">[7:0]   01101111  CRC7 + end bit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">07 02 00 07 00 79
</span></span></code></pre></div><p><code>CMD16</code> is shown below. The value <code>0x12</code> (decimal 18) sets the block length to 18 bytes (2 bytes for header/length + 16 bytes for the password).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">50 00 00 00 12 2F
</span></span><span class="line"><span class="cl">[47:41] 01010000  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 00000000
</span></span><span class="line"><span class="cl">[31:24] 00000000
</span></span><span class="line"><span class="cl">[23:16] 00000000
</span></span><span class="line"><span class="cl">[15:8]  00010010  SET_BLOCKLEN
</span></span><span class="line"><span class="cl">[7:0]   00101111  CRC7 + end bit
</span></span></code></pre></div><p><code>CMD16</code> response:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">10 02 00 09 00 07
</span></span><span class="line"><span class="cl">[47:41] 00010000  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 00000010  Card Status
</span></span><span class="line"><span class="cl">[31:24] 00000000  Card Status
</span></span><span class="line"><span class="cl">[23:16] 00001001  Card Status
</span></span><span class="line"><span class="cl">[15:8]  00000000  Card Status
</span></span><span class="line"><span class="cl">[7:0]   00000111  CRC7 + end bit
</span></span></code></pre></div><p>The first byte of the <code>CMD42</code> response is <code>00101010</code> (<code>0x2A</code>), indicating an R1 response.</p>
<p>I captured the <code>CMD42</code> response using a logic analyzer.</p>
<p>Decoding the Parameter field reveals the card status: <strong>Locked</strong>, <strong>Ready</strong>, <strong>Transfer Mode</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">2a <span class="m">02</span> <span class="m">00</span> <span class="m">09</span> <span class="m">00</span> 6f
</span></span><span class="line"><span class="cl"><span class="o">[</span>47:41<span class="o">]</span> <span class="m">00010000</span>  start bit + Command index
</span></span><span class="line"><span class="cl"><span class="o">[</span>40:32<span class="o">]</span> <span class="m">00000010</span>  Card Status Locked
</span></span><span class="line"><span class="cl"><span class="o">[</span>31:24<span class="o">]</span> <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>23:16<span class="o">]</span> <span class="m">00001001</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>15:8<span class="o">]</span>  <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>7:0<span class="o">]</span>   <span class="m">00000111</span>  CRC7 + end bit
</span></span></code></pre></div><p>Following the delivery of <code>CMD42</code> data, <code>CMD13</code> is sent to check status. The CSR bits now indicate: <strong>Unlocked</strong>, <strong>Ready</strong>, <strong>Transfer Mode</strong>, with <code>APP_CMD</code> disabled.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">0D <span class="m">00</span> <span class="m">00</span> <span class="m">09</span> <span class="m">00</span> <span class="m">07</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>47:41<span class="o">]</span> <span class="m">00010000</span>  start bit + Command index
</span></span><span class="line"><span class="cl"><span class="o">[</span>40:32<span class="o">]</span> <span class="m">00000000</span>  Card Status Unlocked
</span></span><span class="line"><span class="cl"><span class="o">[</span>31:24<span class="o">]</span> <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>23:16<span class="o">]</span> <span class="m">00001001</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>15:8<span class="o">]</span>  <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>7:0<span class="o">]</span>   <span class="m">01101111</span>  CRC7 + end bit
</span></span></code></pre></div><h3 id="data-analysis">Data Analysis</h3>
<p>In KingstVIS, I located the Data0 channel, aligned it to the rising edge following <code>CMD42</code>, selected the relevant interval, and exported the clock and Data0 channels to a TXT file.</p>
<p><img loading="lazy"  src="./exporting_data.png"
        alt="exporting_data"/></p>
<p>The exported data is effectively CSV-formatted. Note that KingstVIS exports to CSV in reverse chronological order, so the TXT format was preferred. The encoding is ANSI, which may display incorrectly on Linux; simply removing the header line resolved this.</p>
<p><img loading="lazy"  src="./csv_data_exported.png"
        alt="csv_data_exported"/></p>
<p>The script below parses the Data0 output into a readable format.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -*- coding: utf-8 -*-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">csv</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">getopt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">binascii</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">parse_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_ch0_v</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="n">bits</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">current_ch0_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">current_ch0_v</span> <span class="o">^</span> <span class="n">last_ch0_v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">last_ch0_v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">bits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
</span></span><span class="line"><span class="cl">                <span class="n">last_ch0_v</span> <span class="o">=</span> <span class="n">current_ch0_v</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">bits</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">crc16_calc</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">crc</span> <span class="o">=</span> <span class="mh">0x0000</span>
</span></span><span class="line"><span class="cl">    <span class="n">poly</span> <span class="o">=</span> <span class="mh">0x1021</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur_byte</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">bit</span> <span class="o">=</span> <span class="p">((</span><span class="n">cur_byte</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">c15</span> <span class="o">=</span> <span class="p">((</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">crc</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">c15</span> <span class="o">^</span> <span class="n">bit</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">crc</span> <span class="o">^=</span> <span class="n">poly</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">usage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&#34;f:o&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">csv_file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">output_file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;-f&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">csv_file</span> <span class="o">=</span> <span class="n">arg</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;-o&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">output_file</span> <span class="o">=</span> <span class="n">arg</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">bits</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">keys_list</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="n">crc_data</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="n">keys_len</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Remove the first start bit of Data</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="mi">8</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">byte</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> \
</span></span><span class="line"><span class="cl">                    <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CMD42 data block parameters error.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Keys length: &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">keys_len</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;-bytes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                    <span class="n">crc_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">crc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="n">crc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">crc16_calc</span><span class="p">(</span><span class="n">keys_list</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                        <span class="n">x</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">keys_list</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">keys_len</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Key:&#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">2</span><span class="p">:(</span><span class="n">keys_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CRC:&#34;</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">crc16_calc</span><span class="p">(</span><span class="n">keys_list</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">Analysis completed!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CRC error!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Data Error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">usage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">usage</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Usage:python kinstvis_sdio_parser.py -f test.csv&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>After removing the start bit, parsing the <code>CMD42</code> data structure, and verifying the CRC, the analysis confirmed a valid password.</p>
<p><img loading="lazy"  src="./parse_key.png"
        alt="parse_key"/></p>
<p>Extracted password:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">5ffca19ffcdb5899a82c4e265f99c76b
</span></span></code></pre></div><h2 id="mmc-utils">MMC Utils</h2>
<p>The next step involved creating an SD unlock tool. Micron‚Äôs documentation provides a demo for adding lock/unlock functionality; I modified <code>mmc-utils</code> to implement this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc-utils.git
</span></span></code></pre></div><p><code>mmc-utils/mmc.h</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define MMC_SET_BLOCKLEN        16 </span><span class="cm">/* ac [31:0] block len R1 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_UNLOCK         42 </span><span class="cm">/* adtc R1b */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_UNLOCK        0x0 </span><span class="cm">/* UNLOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_SET_PWD       0x1 </span><span class="cm">/* SET_PWD */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_CLR_PWD       0x2 </span><span class="cm">/* CLR_PWD */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_LOCK          0x4 </span><span class="cm">/* LOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_SET_LOCK      0x5 </span><span class="cm">/* SET_PWD &amp; LOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_ERASE         0x8 </span><span class="cm">/* ERASE */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_PWD_LENGTH          32 </span><span class="cm">/* max PWDS_LEN: old+new */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_BLOCK_SIZE          512 </span><span class="cm">/* data blk size for cmd42 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_R1_ERROR            (1 &lt;&lt; 19) </span><span class="cm">/* R1 bit19 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_R1_LOCK_ULOCK_FAIL  (1 &lt;&lt; 24) </span><span class="cm">/* R1 bit24 */</span><span class="cp">
</span></span></span></code></pre></div><p><code>mmc-utils/mmc.c</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">{</span><span class="n">do_lock_unlock</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;cmd42&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;password&gt; &lt;s|c|l|u|e&gt; &lt;device&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;s</span><span class="se">\t</span><span class="s">set password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;c</span><span class="se">\t</span><span class="s">clear password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;l</span><span class="se">\t</span><span class="s">lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;sl</span><span class="se">\t</span><span class="s">set password and lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;u</span><span class="se">\t</span><span class="s">unlock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;e</span><span class="se">\t</span><span class="s">force erase</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nb">NULL</span><span class="p">},</span>
</span></span></code></pre></div><p><code>mmc-utils/mmc_cmds.h</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//lock/unlock feature implementation
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">do_lock_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">nargs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u8</span> <span class="n">data_block</span><span class="p">[</span><span class="n">MMC_BLOCK_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u8</span> <span class="n">data_block_onebyte</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_ioc_cmd</span> <span class="n">idata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmd42_para</span><span class="p">;</span>               <span class="c1">//parameter of cmd42
</span></span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">pwd</span><span class="p">[</span><span class="n">MAX_PWD_LENGTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//password
</span></span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pwd_len</span><span class="p">;</span>                  <span class="c1">//password length
</span></span></span><span class="line"><span class="cl">    <span class="n">__u32</span> <span class="n">r1_response</span><span class="p">;</span>            <span class="c1">//R1 response token
</span></span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nargs</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Usage: mmc cmd42 &lt;password&gt; &lt;s|c|l|u|e&gt; &lt;device&gt; </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">strcpy</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pwd_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_SET_PWD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set password: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_CLR_PWD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Clear password: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_LOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Lock the card: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;sl&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_SET_LOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set password and lock the card: password - %s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;u&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_UNLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Unlock the card: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Force erase ... (Warning: all card data will be erased together with PWD!)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Invalid parameter:</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;s</span><span class="se">\t</span><span class="s">set password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;c</span><span class="se">\t</span><span class="s">clear password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;l</span><span class="se">\t</span><span class="s">lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;sl</span><span class="se">\t</span><span class="s">set password and lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;u</span><span class="se">\t</span><span class="s">unlock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;e</span><span class="se">\t</span><span class="s">force erase</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">device</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">nargs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;open&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//set blk size to 2-byte for Force Erase @DDR50 compability
</span></span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">MMC_BLOCK_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">set_block_len</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span> <span class="c1">//set data block size prior to cmd42
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set to data block length = %d byte(s).</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block_onebyte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd42_para</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd42_para</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwd_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">data_block</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pwd</span><span class="p">,</span> <span class="n">pwd_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">idata</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">write_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_LOCK_UNLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//set all 0 for cmd42 arg
</span></span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span> <span class="o">|</span> <span class="n">MMC_CMD_ADTC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">blksz</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mmc_ioc_cmd_set_data</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">data_block_onebyte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mmc_ioc_cmd_set_data</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">data_block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">MMC_IOC_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idata</span><span class="p">);</span> <span class="c1">//Issue CMD42
</span></span></span><span class="line"><span class="cl">    <span class="n">r1_response</span> <span class="o">=</span> <span class="n">idata</span><span class="p">.</span><span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;cmd42 response: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_ERROR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">//check CMD42 error
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;cmd42 error! Error code: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_ERROR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_LOCK_ULOCK_FAIL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//check lock/unlock error
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Card lock/unlock fail! Error code: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_LOCK_ULOCK_FAIL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//change data block length
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">set_block_len</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blk_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_ioc_cmd</span> <span class="n">idata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">idata</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_SET_BLOCKLEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">blk_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">MMC_IOC_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idata</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In practice, this is controlled via <code>ioctl</code>. After compilation, I successfuly locked the card, but subsequent unlock attempts failed. I had to pivot to another approach.</p>
<p><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/mmc/ioctl.h"target="_blank" rel="noopener noreferrer">https://github.com/torvalds/linux/blob/master/include/uapi/linux/mmc/ioctl.h</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo ./mmc scr <span class="nb">read</span> /sys/bus/mmc/devices/mmc0:aaaa/
</span></span><span class="line"><span class="cl">type: <span class="s1">&#39;SD&#39;</span>
</span></span><span class="line"><span class="cl">version: SD 3.0x
</span></span><span class="line"><span class="cl">bus widths: 4bit, 1bit,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo ./mmc cmd42 <span class="m">123456</span> s /sys/bus/mmc/devices/mmc0:aaaa/
</span></span><span class="line"><span class="cl">Set password: <span class="nv">password</span><span class="o">=</span><span class="m">123456</span> ...
</span></span></code></pre></div><h2 id="modification-of-the-kernel-module">Modification of the Kernel Module</h2>
<p>Since existing user-space tools fell short, I proceeded to modify the kernel module directly. My development environment was Arch Linux. As the MMC driver is compiled as a module, I could modify it without rebuilding the entire kernel (unlike certain Ubuntu configurations where it may be built-in).</p>
<p>The relevant kernel module directories on Arch Linux are listed below. Testing was performed on an HP 840G3 laptop where the SD card reader is connected via the PCI bus. The following drivers are involved:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/core/mmc_core.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/core/mmc_block.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/host/rtsx_pci_sdmmc.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/misc/cardreader/rtsx_pci.ko.xz
</span></span></code></pre></div><p>When building kernel modules from source, <code>vermagic</code> mismatch errors can occur if the kernel version or CPU feature flags do not align with the running kernel. Additionally, since kernel 3.7, Linux enforces module signing; lacking a valid signature can prevent module loading. Use <code>modinfo</code> to inspect the module properties.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ modinfo mmc_core
</span></span><span class="line"><span class="cl">filename:       /lib/modules/4.18.10-arch1-1-ARCH/kernel/drivers/mmc/core/mmc_core.ko.xz
</span></span><span class="line"><span class="cl">license:        GPL
</span></span><span class="line"><span class="cl">srcversion:     72D2DBEB18AB4B898BE5331
</span></span><span class="line"><span class="cl">depends:
</span></span><span class="line"><span class="cl">retpoline:      Y
</span></span><span class="line"><span class="cl">intree:         Y
</span></span><span class="line"><span class="cl">name:           mmc_core
</span></span><span class="line"><span class="cl">vermagic:       4.18.10-arch1-1-ARCH SMP preempt mod_unload modversions
</span></span><span class="line"><span class="cl">sig_id:         PKCS#7
</span></span><span class="line"><span class="cl">signer:
</span></span><span class="line"><span class="cl">sig_key:
</span></span><span class="line"><span class="cl">sig_hashalgo:   md4
</span></span><span class="line"><span class="cl">signature:      30:82:02:A5:06:09:2A:86:48:86:F7:0D:01:07:02:A0:82:02:96:30
</span></span><span class="line"><span class="cl">                ‰ª•‰∏ãÁúÅÁï•
</span></span><span class="line"><span class="cl">parm:           use_spi_crc:bool
</span></span></code></pre></div><p>We can build directly in <code>/usr/lib/modules/$(uname -r)/build/</code> without additional configuration. Simply copy the MMC core code to the target directory, run <code>make</code>, and reload the modules.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp ./core/* /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/mmc/core/
</span></span><span class="line"><span class="cl">make modules <span class="nv">SUBDIRS</span><span class="o">=</span>drivers/mmc/core
</span></span><span class="line"><span class="cl">  Building modules, stage 2.
</span></span><span class="line"><span class="cl">  MODPOST <span class="m">7</span> modules
</span></span><span class="line"><span class="cl">rmmod rtsx_pci_sdmmc <span class="o">&amp;&amp;</span> rmmod mmc_core
</span></span><span class="line"><span class="cl">insmod /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/mmc/core/mmc_core.ko
</span></span><span class="line"><span class="cl">insmod /lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/kernel/drivers/mmc/host/rtsx_pci_sdmmc.ko.xz
</span></span></code></pre></div><h3 id="add-unlock-function">Add Unlock Function</h3>
<p>Add the <code>unlock_mmc</code> declaration in <code>mmc_ops.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unlock_mmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">key_buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">key_len</span><span class="p">);</span>
</span></span></code></pre></div><p>Then implement it: first set the block length, then send the CMD42 ADTC command.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unlock_mmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">key_buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">key_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">key_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_request</span> <span class="n">mrq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_command</span> <span class="n">cmd_sbl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_command</span> <span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_data</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="o">*</span><span class="n">data_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*------------CMD 16----------------*/</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1 byteflag + 1 byte password length + 16 bytes password
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_sbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_command</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_SET_BLOCKLEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="nf">mmc_wait_for_cmd</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_sbl</span><span class="p">,</span> <span class="n">MMC_CMD_RETRIES</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s failed block_size=%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">,</span><span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*-----------CMD 42-----------------*/</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// CMD
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_command</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_LOCK_UNLOCK</span><span class="p">;</span> <span class="c1">// CMD 42
</span></span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// set all 0 for cmd42 arg
</span></span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_ADTC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Data
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">timeout_ns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">blksz</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_DATA_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">sg_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mmc_set_data_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_request</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">mrq</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mrq</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set Data for DMA
</span></span></span><span class="line"><span class="cl">    <span class="n">data_buf</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s kzalloc failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">data_buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// request
</span></span></span><span class="line"><span class="cl">    <span class="nf">mmc_wait_for_req</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mrq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s: unlock cmd error %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[SDLOCK] %s MMC_LOCK_UNLOCK </span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">(</span><span class="n">data_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Before <code>mmc_sd_setup_card</code> in <code>sd.c</code>, add the unlock logic.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">// Check <span class="k">if</span> locked
</span></span><span class="line"><span class="cl">u32 <span class="nv">status</span> <span class="o">=</span> 0<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">err</span> <span class="o">=</span> mmc_send_status<span class="o">(</span>card, <span class="p">&amp;</span>status<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">    goto free_card<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    mmc_card_set_encrypted<span class="o">(</span>card<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    mmc_card_set_locked<span class="o">(</span>card<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// For debugging convenience
</span></span><span class="line"><span class="cl">bool <span class="nv">auto_unlock</span> <span class="o">=</span> true<span class="p">;</span>
</span></span><span class="line"><span class="cl">char unlock_pwd<span class="o">[</span>16<span class="o">]</span> <span class="o">=</span> <span class="o">{</span>0x5f,0xfc,0xa1,0x9f,0xfc,0xdb,0x58,0x99,0xa8,0x2c,0x4e,0x26,0x5f,0x99,0xc7,0x6b<span class="o">}</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="o">(</span>auto_unlock<span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        //unlock sd card
</span></span><span class="line"><span class="cl">        <span class="nv">err</span> <span class="o">=</span> unlock_mmc<span class="o">(</span>card, unlock_pwd, 16<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock failed \n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success \n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="o">(</span>!mmc_card_locked<span class="o">(</span>card<span class="o">))</span>
</span></span><span class="line"><span class="cl">            <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">auto_unlock</span> <span class="o">=</span> false<span class="p">;</span>
</span></span><span class="line"><span class="cl">                printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success and sdcard status is unlocked.\n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="o">{</span>
</span></span><span class="line"><span class="cl">                printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success but sdcard status is locked, abnormal status.\n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        //Check <span class="k">if</span> card is locked
</span></span><span class="line"><span class="cl">        <span class="nv">err</span> <span class="o">=</span> mmc_send_status<span class="o">(</span>card, <span class="p">&amp;</span>status<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s resume sd card exception /n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            goto free_card<span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard is locked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        goto <span class="k">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard resume to unlocked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard is unlocked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Next, define the necessary macros in <code>card.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define mmc_card_mmc(c)     ((c)-&gt;type == MMC_TYPE_MMC)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_sd(c)      ((c)-&gt;type == MMC_TYPE_SD)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_sdio(c)    ((c)-&gt;type == MMC_TYPE_SDIO)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_locked(c)  ((c)-&gt;state &amp; MMC_STATE_LOCKED)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_encrypt(c) ((c)-&gt;state &amp; MMC_STATE_ENCRYPT)
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_PRESENT        (1&lt;&lt;0)       </span><span class="cm">/* present in sysfs */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_READONLY       (1&lt;&lt;1)       </span><span class="cm">/* card is read-only */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_BLOCKADDR      (1&lt;&lt;2)       </span><span class="cm">/* card uses block-addressing */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CARD_SDXC            (1&lt;&lt;3)       </span><span class="cm">/* card is SDXC */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CARD_REMOVED         (1&lt;&lt;4)       </span><span class="cm">/* card has been removed */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_DOING_BKOPS    (1&lt;&lt;5)       </span><span class="cm">/* card is doing BKOPS */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_LOCKED         (1&lt;&lt;12)      </span><span class="cm">/* card is currently locked */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_ENCRYPT        (1&lt;&lt;13)      </span><span class="cm">/* card is currently encrypt */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_ULTRAHIGHSPEED (1&lt;&lt;14)      </span><span class="cm">/* card is in ultra high speed mode */</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_SUSPENDED      (1&lt;&lt;6)       </span><span class="cm">/* card is suspended */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_CMDQ           (1&lt;&lt;7)       </span><span class="cm">/* card is in cmd queue mode */</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_ERASE      (1&lt;&lt;3)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_LOCK       (1&lt;&lt;2)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_CLR_PWD    (1&lt;&lt;1)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_SET_PWD    (1&lt;&lt;0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_UNLOCK     0
</span></span></span></code></pre></div><p>To debug, I added instrumentation to <code>mmc_wait_for_req_done</code> within <code>core.c</code> and monitored the logs using <code>dmesg</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[mmc] CMD %d err number: %d&#34;</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="uhs-i">UHS-I</h2>
<p>UHS-I (Ultra High Speed Phase I) is a bus interface designed for high-speed data transfer on SDHC and SDXC cards. It supports Low Voltage Signaling (LVS) and offers seven operating modes:</p>
<ul>
<li><strong>DS</strong> (Default Speed): Up to 25MHz, 3.3V signaling</li>
<li><strong>HS</strong> (High Speed): Up to 50MHz, 3.3V signaling</li>
<li><strong>SDR12</strong>: SDR up to 25MHz, 1.8V signaling</li>
<li><strong>SDR25</strong>: SDR up to 50MHz, 1.8V signaling</li>
<li><strong>SDR50</strong>: SDR up to 100MHz, 1.8V signaling</li>
<li><strong>SDR104</strong>: SDR up to 208MHz, 1.8V signaling</li>
<li><strong>DDR50</strong>: DDR up to 50MHz, 1.8V signaling</li>
</ul>
<p>Initially, <code>CMD0</code> is used to select the bus mode (SPI or SD mode). Note that 1.8V signaling is only available in SD mode.</p>
<p><img loading="lazy"  src="./uhs_command_sequence.png"
        alt="uhs_command_sequence"/></p>
<p>As shown in the logs below, the unlock attempt failed; <code>CMD42</code> returned error <code>-22</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ dmesg -l 0,1,2,3,4,5,6,7
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.072102<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">52</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.175620<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">52</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.177592<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">0</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.181590<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">8</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.282033<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.385534<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.492060<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.595641<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.596514<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.597226<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.626822<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">0</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.630372<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">8</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.631051<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.631758<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.642862<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.643590<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.656036<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.656752<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.669827<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.670711<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.683086<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.683976<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.685084<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">2</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.685781<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">3</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.686493<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">13</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.687827<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">9</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.688551<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">7</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.689227<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">16</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690033<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">42</span> err number: -22
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690041<span class="o">]</span> unlock_mmc: unlock cmd error -22
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690045<span class="o">]</span> <span class="o">[</span>SDLOCK<span class="o">]</span> mmc_sd_init_card unlock failed
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690749<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">13</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690755<span class="o">]</span> <span class="o">[</span>SDLOCK<span class="o">]</span> sdcard is locked
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690773<span class="o">]</span> mmc0: new SD card at address f317
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.691709<span class="o">]</span> mmcblk0: mmc0:f317 MF02B 1.88 GiB
</span></span></code></pre></div><p>Linux error <code>-22</code> corresponds to <code>EINVAL</code> (Invalid Argument). I traced the error propagation through the driver stack, eventually reaching <code>drivers/mmc/host/sdhci.c</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">filename: drivers/mmc/core/core.c
</span></span><span class="line"><span class="cl">functions:
</span></span><span class="line"><span class="cl">mmc_wait_for_req -&gt; __mmc_start_request -&gt; host-&gt;ops-&gt;request
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">filename: drivers/mmc/host/rtsx_pci_sdmmc.c
</span></span><span class="line"><span class="cl">functions:
</span></span><span class="line"><span class="cl">sdmmc_request -&gt; schedule_work -&gt; sd_request -&gt; sd_send_cmd_get_rsp -&gt; sd_normal_rw -&gt; sd_write_data -&gt; rtsx_pci_write_ppbuf -&gt; rtsx_pci_send_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">filename: drivers/misc/cardreader/rtsx_pcr.c
</span></span><span class="line"><span class="cl">rtsx_pci_write_ppbuf
</span></span><span class="line"><span class="cl">rtsx_pci_add_cmd
</span></span><span class="line"><span class="cl">rtsx_pci_send_cmd
</span></span></code></pre></div><p>Since I am testing on a laptop with a Realtek SD card reader, the relevant code is in the Realtek PCI driver (<code>rtsx_pci</code>). On embedded devices or phones, this might correspond to <code>drivers/mfd/rtsx_pcr.c</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rtsx_pci_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtsx_pcr</span> <span class="o">*</span><span class="n">pcr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pcr</span><span class="o">-&gt;</span><span class="n">trans_result</span> <span class="o">==</span> <span class="n">TRANS_RESULT_FAIL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp ./drivers/misc/cardreader/* /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/misc/cardreader/
</span></span><span class="line"><span class="cl">make modules <span class="nv">SUBDIRS</span><span class="o">=</span>drivers/misc/cardreader
</span></span></code></pre></div><p>By inspecting the parameters passed to <code>rtsx_pci_add_cmd</code>, I verified that the key was being transmitted correctly.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sd_cmd_set_sd_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016095] [rtsx] cmd_type:1, reg_addr:fda9, ptr:0x50, val:2108292944 SD_CMD0 16
</span></span><span class="line"><span class="cl">[75754.016100] [rtsx] cmd_type:1, reg_addr:fdaa, ptr:0x0, val:2108358400  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016104] [rtsx] cmd_type:1, reg_addr:fdab, ptr:0x0, val:2108423936  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016111] [rtsx] cmd_type:1, reg_addr:fdac, ptr:0x0, val:2108489472  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016115] [rtsx] cmd_type:1, reg_addr:fdad, ptr:0x12, val:2108555026 SD_CMD4 0x12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_send_cmd_get_rsp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016119] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x1, val:2107768577  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.016122] [rtsx] cmd_type:1, reg_addr:fd5b, ptr:0x1, val:2103116033  CARD_DATA_SOURCE
</span></span><span class="line"><span class="cl">[75754.016126] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x88, val:2108948360  WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.016130] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x60, val:-1112317856 CHECK_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016134] [rtsx] cmd_type:0, reg_addr:fda9, ptr:0x0, val:1034485760  sd_cmd_set_sd_cmd 0
</span></span><span class="line"><span class="cl">[75754.016138] [rtsx] cmd_type:0, reg_addr:fdaa, ptr:0x0, val:1034551296  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016142] [rtsx] cmd_type:0, reg_addr:fdab, ptr:0x0, val:1034616832  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016146] [rtsx] cmd_type:0, reg_addr:fdac, ptr:0x0, val:1034682368  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016150] [rtsx] cmd_type:0, reg_addr:fdad, ptr:0x0, val:1034747904  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016153] [rtsx] cmd_type:0, reg_addr:fda3, ptr:0x0, val:1034092544  SD_STAT1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_cmd_set_sd_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016787] [SDLOCK] unlock_mmc MMC_SET_BLOCKLEN 18
</span></span><span class="line"><span class="cl">[75754.016820] [rtsx] cmd_type:1, reg_addr:fda9, ptr:0x6a, val:2108292970 SD_CMD0 42
</span></span><span class="line"><span class="cl">[75754.016823] [rtsx] cmd_type:1, reg_addr:fdaa, ptr:0x0, val:2108358400  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016826] [rtsx] cmd_type:1, reg_addr:fdab, ptr:0x0, val:2108423936  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016829] [rtsx] cmd_type:1, reg_addr:fdac, ptr:0x0, val:2108489472  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016831] [rtsx] cmd_type:1, reg_addr:fdad, ptr:0x0, val:2108555008  SD_CMD4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016834] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x1, val:2107768577  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.016837] [rtsx] cmd_type:1, reg_addr:fd5b, ptr:0x1, val:2103116033  CARD_DATA_SOURCE
</span></span><span class="line"><span class="cl">[75754.016839] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x88, val:2108948360 WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.016842] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x60, val:-1112317856 CHECK_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016845] [rtsx] cmd_type:0, reg_addr:fda9, ptr:0x0, val:1034485760  sd_cmd_set_sd_cmd 0
</span></span><span class="line"><span class="cl">[75754.016848] [rtsx] cmd_type:0, reg_addr:fdaa, ptr:0x0, val:1034551296  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016851] [rtsx] cmd_type:0, reg_addr:fdab, ptr:0x0, val:1034616832  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016854] [rtsx] cmd_type:0, reg_addr:fdac, ptr:0x0, val:1034682368  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016856] [rtsx] cmd_type:0, reg_addr:fdad, ptr:0x0, val:1034747904  SD_CMD4
</span></span><span class="line"><span class="cl">[75754.016862] [rtsx] cmd_type:0, reg_addr:fda3, ptr:0x0, val:1034092544  SD_STAT1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">write data
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017492] [rtsx] cmd_type:1, reg_addr:fa00, ptr:0x0, val:2046885632
</span></span><span class="line"><span class="cl">[75754.017496] [rtsx] cmd_type:1, reg_addr:fa01, ptr:0x10, val:2046951184
</span></span><span class="line"><span class="cl">[75754.017499] [rtsx] cmd_type:1, reg_addr:fa02, ptr:0x5f, val:2047016799
</span></span><span class="line"><span class="cl">[75754.017502] [rtsx] cmd_type:1, reg_addr:fa03, ptr:0xfc, val:2047082492
</span></span><span class="line"><span class="cl">[75754.017505] [rtsx] cmd_type:1, reg_addr:fa04, ptr:0xa1, val:2047147937
</span></span><span class="line"><span class="cl">[75754.017508] [rtsx] cmd_type:1, reg_addr:fa05, ptr:0x9f, val:2047213471
</span></span><span class="line"><span class="cl">[75754.017511] [rtsx] cmd_type:1, reg_addr:fa06, ptr:0xfc, val:2047279100
</span></span><span class="line"><span class="cl">[75754.017513] [rtsx] cmd_type:1, reg_addr:fa07, ptr:0xdb, val:2047344573
</span></span><span class="line"><span class="cl">[75754.017518] [rtsx] cmd_type:1, reg_addr:fa08, ptr:0x58, val:2047410008
</span></span><span class="line"><span class="cl">[75754.017521] [rtsx] cmd_type:1, reg_addr:fa09, ptr:0x99, val:2047475609
</span></span><span class="line"><span class="cl">[75754.017524] [rtsx] cmd_type:1, reg_addr:fa0a, ptr:0xa8, val:2047541160
</span></span><span class="line"><span class="cl">[75754.017526] [rtsx] cmd_type:1, reg_addr:fa0b, ptr:0x2c, val:2047606572
</span></span><span class="line"><span class="cl">[75754.017529] [rtsx] cmd_type:1, reg_addr:fa0c, ptr:0x4e, val:2047672142
</span></span><span class="line"><span class="cl">[75754.017531] [rtsx] cmd_type:1, reg_addr:fa0d, ptr:0x26, val:2047737638
</span></span><span class="line"><span class="cl">[75754.017534] [rtsx] cmd_type:1, reg_addr:fa0e, ptr:0x5f, val:2047803231
</span></span><span class="line"><span class="cl">[75754.017537] [rtsx] cmd_type:1, reg_addr:fa0f, ptr:0x99, val:2047868825
</span></span><span class="line"><span class="cl">[75754.017539] [rtsx] cmd_type:1, reg_addr:fa10, ptr:0xc7, val:2047934407
</span></span><span class="line"><span class="cl">[75754.017542] [rtsx] cmd_type:1, reg_addr:fa11, ptr:0x6b, val:2047999851
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_cmd_set_block_len
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017569] [rtsx] cmd_type:1, reg_addr:fdb1, ptr:0x1, val:2108817153  SD_BLOCK_CNT_L 1
</span></span><span class="line"><span class="cl">[75754.017572] [rtsx] cmd_type:1, reg_addr:fdb2, ptr:0x0, val:2108882688  SD_BLOCK_CNT_H
</span></span><span class="line"><span class="cl">[75754.017575] [rtsx] cmd_type:1, reg_addr:fdaf, ptr:0x12, val:2108686098 SD_BYTE_CNT_L  18
</span></span><span class="line"><span class="cl">[75754.017577] [rtsx] cmd_type:1, reg_addr:fdb0, ptr:0x0, val:2108751616  SD_BYTE_CNT_H
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017580] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x0, val:2107768576  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.017583] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x81, val:2108948353 WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.017585] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x40, val:-1112326080 CHECK_REG_CMD SD_TRANSFER
</span></span></code></pre></div><h2 id="unlocking-sd-card-via-raspberry-pi">Unlocking SD Card via Raspberry Pi</h2>
<p>Since the Realtek driver proved problematic, I switched to using a Raspberry Pi.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo dd <span class="nv">bs</span><span class="o">=</span>4M <span class="k">if</span><span class="o">=</span>/home/cygnus/IMG/2018-06-27-raspbian-stretch-lite/2018-06-27-raspbian-stretch-lite.img <span class="nv">of</span><span class="o">=</span>/dev/mmcblk0 <span class="nv">status</span><span class="o">=</span>progress <span class="nv">conv</span><span class="o">=</span>fsync
</span></span></code></pre></div><p>I downloaded the appropriate Raspberry Pi kernel source and added the cross-compilation toolchain to my PATH:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone --depth<span class="o">=</span><span class="m">1</span> --branch rpi-4.14.y https://github.com/raspberrypi/linux
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/home/cygnus/git/rapi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin
</span></span></code></pre></div><p>I used the <code>BCM2709</code> configuration. In <code>menuconfig</code>, I configured the SD card and MMC drivers to be built as modules. Finally, I built the <code>zImage</code>, modules, and device tree blobs (dtbs), and updated the files on the boot partition.</p>
<ul>
<li><code>kernel.img</code>: RPi 1B, 1A, A+, B+, 2B (v1), Zero, Zero W, CM1</li>
<li><code>kernel7.img</code>: RPi 2B (v2), 3B, CM3, CM3L</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">KERNEL</span><span class="o">=</span>kernel7
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- bcm2709_defconfig
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- menuconfig
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- -j16 zImage modules dtbs
</span></span><span class="line"><span class="cl">sudo make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>/run/media/cygnus/rootfs modules_install
</span></span></code></pre></div><p>Update kernel:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo cp /run/media/cygnus/boot/<span class="nv">$KERNEL</span>.img /run/media/cygnus/boot/<span class="nv">$KERNEL</span>-backup.img
</span></span><span class="line"><span class="cl">sudo cp arch/arm/boot/zImage /run/media/cygnus/boot/<span class="nv">$KERNEL</span>.img
</span></span></code></pre></div><p>Update device trees:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo cp arch/arm/boot/dts/*.dtb /run/media/cygnus/boot/
</span></span><span class="line"><span class="cl">sudo cp arch/arm/boot/dts/overlays/*.dtb* /run/media/cygnus/boot/overlays/
</span></span></code></pre></div><p>Add the following to the boot config:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">dtoverlay</span><span class="o">=</span>sdio,poll_once<span class="o">=</span>off
</span></span></code></pre></div><p>Wire the SD card to the Raspberry Pi GPIO pins as follows:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: right">Name</th>
          <th style="text-align: center">SD Card</th>
          <th style="text-align: left">Raspberry Pi Pin Num</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: right">VCC</td>
          <td style="text-align: center">4</td>
          <td style="text-align: left">17</td>
      </tr>
      <tr>
          <td style="text-align: right">GND</td>
          <td style="text-align: center">6</td>
          <td style="text-align: left">20</td>
      </tr>
      <tr>
          <td style="text-align: right">CLK/SCLK</td>
          <td style="text-align: center">5</td>
          <td style="text-align: left">15</td>
      </tr>
      <tr>
          <td style="text-align: right">CMD/MOSI</td>
          <td style="text-align: center">2</td>
          <td style="text-align: left">16</td>
      </tr>
      <tr>
          <td style="text-align: right">DAT0/MISO</td>
          <td style="text-align: center">7</td>
          <td style="text-align: left">18</td>
      </tr>
      <tr>
          <td style="text-align: right">DAT1</td>
          <td style="text-align: center">8</td>
          <td style="text-align: left">22</td>
      </tr>
      <tr>
          <td style="text-align: right">DAT2</td>
          <td style="text-align: center">9</td>
          <td style="text-align: left">37</td>
      </tr>
      <tr>
          <td style="text-align: right">DAT3/CS</td>
          <td style="text-align: center">1</td>
          <td style="text-align: left">13</td>
      </tr>
  </tbody>
</table>
<h2 id="reference">Reference</h2>
<p><a href="https://www.sdcard.org/downloads/pls/index.html"target="_blank" rel="noopener noreferrer">SD Simplified Specifications</a></p>
<p><a href="https://en.wikipedia.org/wiki/Secure_Digital"target="_blank" rel="noopener noreferrer">Wiki - Secure_Digital</a></p>
<p><a href="https://www.sdcard.org/developers/overview/index.html"target="_blank" rel="noopener noreferrer">SD Standard Overview</a></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/sd-card/>SD card</a><a class="tag" href=/en/tags/sd-specification/>SD specification</a><a class="tag" href=/en/tags/sdio/>SDIO</a></section>
</div>

<div class="toc-wrapper">
    <div class="toc-content-box" id="toc-content-box">
        <div class="toc-header">Table of Contents</div>
        <nav id="TableOfContents">
  <ol>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#io-information">I/O Information</a></li>
    <li><a href="#registers">Registers</a></li>
    <li><a href="#architecture">Architecture</a>
      <ol>
        <li><a href="#sdio">SDIO</a></li>
      </ol>
    </li>
    <li><a href="#sd-bus-protocol">SD Bus Protocol</a>
      <ol>
        <li><a href="#cmd-format">CMD Format</a></li>
        <li><a href="#data-packet-format">Data Packet Format</a></li>
        <li><a href="#crc7">CRC7</a></li>
        <li><a href="#crc16">CRC16</a></li>
      </ol>
    </li>
    <li><a href="#response-type">Response Type</a>
      <ol>
        <li><a href="#formats-for-different-response-types">Formats for different response types</a></li>
      </ol>
    </li>
    <li><a href="#function-mode">Function mode</a></li>
    <li><a href="#command">Command</a></li>
    <li><a href="#application-specific-commands">Application-Specific Commands</a></li>
    <li><a href="#status-information">Status Information</a></li>
    <li><a href="#sd-protocol-sniff">SD Protocol Sniff</a></li>
    <li><a href="#sd-unlock">SD Unlock</a>
      <ol>
        <li><a href="#cmd-42">CMD 42</a></li>
        <li><a href="#cmd-42-1">CMD 42</a></li>
        <li><a href="#data-analysis">Data Analysis</a></li>
      </ol>
    </li>
    <li><a href="#mmc-utils">MMC Utils</a></li>
    <li><a href="#modification-of-the-kernel-module">Modification of the Kernel Module</a>
      <ol>
        <li><a href="#add-unlock-function">Add Unlock Function</a></li>
      </ol>
    </li>
    <li><a href="#uhs-i">UHS-I</a></li>
    <li><a href="#unlocking-sd-card-via-raspberry-pi">Unlocking SD Card via Raspberry Pi</a></li>
    <li><a href="#reference">Reference</a></li>
  </ol>
</nav>
    </div>
    <div class="toc-button" onclick="toggleTOC()" title="">
        
        <svg viewBox="0 0 24 24">
            <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path>
        </svg>
    </div>
</div>

<script>
    function toggleTOC() {
        const tocBox = document.getElementById('toc-content-box');
        if (tocBox.classList.contains('show')) {
            tocBox.classList.remove('show');
            
            
            
            
            
            setTimeout(() => {
                tocBox.style.display = 'none';
            }, 300); 
        } else {
            tocBox.style.display = 'block';
            
            void tocBox.offsetWidth;
            tocBox.classList.add('show');
        }
    }

    
    document.addEventListener('click', function (event) {
        const wrapper = document.querySelector('.toc-wrapper');
        const tocBox = document.getElementById('toc-content-box');
        if (wrapper && !wrapper.contains(event.target) && tocBox.classList.contains('show')) {
            toggleTOC();
        }
    });
</script><div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/tinyscheme-file-io/"><span class="iconfont icon-article"></span>TinyScheme File I/O</a></p><p><a class="link" href="/en/posts/huawei-e5885l-4g-router-tinkering-notes/"><span class="iconfont icon-article"></span>Huawei E5885L 4G Router Tinkering Notes</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>