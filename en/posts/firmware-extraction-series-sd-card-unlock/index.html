<!DOCTYPE html>
<html lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Preface
An SD card (Secure Digital Memory Card) is a storage medium based on NAND flash technology, designed as a replacement for MMC (Multimedia Card). It is commonly used in multimedia players, cameras, and phones, and later became widely used in IoT devices and automotive electronics as well. By physical size, SD cards can be divided into SD, miniSD, and microSD."><title>Firmware Extraction Series - SD Card Unlock&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series - SD Card Unlock" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series - SD Card Unlock</h1><p class="article date">Thursday, October 18, 2018<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-sd-card-unlock/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="preface">Preface</h2>
<p>An SD card (Secure Digital Memory Card) is a storage medium based on NAND flash technology, designed as a replacement for MMC (Multimedia Card). It is commonly used in multimedia players, cameras, and phones, and later became widely used in IoT devices and automotive electronics as well. By physical size, SD cards can be divided into SD, miniSD, and microSD.</p>
<p><img loading="lazy"  src="./sd_size.png"
        alt="sd_size"/></p>
<p>There are currently two SD card speed class markings in common use: the ‚Äústandard‚Äù speed class marking and the UHS speed class marking. Different speed classes correspond to different bus modes. The SD Association has also introduced a newer speed class standard, Video Speed Class, which uses the UHS bus. SD card capacity also follows standards, ranging from SDSC to SDUC.</p>
<p><img loading="lazy"  src="./Micro-SD-speeds.png"
        alt="Micro-SD-speeds"/>
<img loading="lazy"  src="./bus_speed_img.jpg"
        alt="bus_speed_img"/></p>
<p>SD card parameters can often be seen on the label sticker or silkscreen.</p>
<p><img loading="lazy"  src="./sd_sticker.png"
        alt="sd_sticker"/></p>
<p>The original name of microSD was TF (Trans-flash Card). SD slots are compatible with MMC cards, and you can also wire an eMMC to an SD slot via fly-wires.</p>
<p><img loading="lazy"  src="./sd_emmc.png"
        alt="sd_emmc"/></p>
<p>This post is based on the SD Physical Layer Simplified Specification, Version 6, and focuses on the unlock mechanism.</p>
<p>SDIO (Secure Digital Input Output) is derived from modifications to the SD Physical Layer specification and is an extension of the SD standard. In addition to SDIO storage cards that support the SDIO specification, it also supports SDIO peripheral devices such as Wi‚ÄëFi modules, GPS modules, CMOS sensor modules, etc.</p>
<h2 id="io-information">I/O Information</h2>
<p>Below is a pin comparison between MMC and SD cards.</p>
<p><img loading="lazy"  src="./pin_compare.gif"
        alt="pin_compare"/></p>
<p>Under different bus protocols and transfer modes, these pins serve different functions. This post mainly focuses on the SD-mode specification. In the Type column, the definitions are:</p>
<ul>
<li>S - Power Supply</li>
<li>I - Input</li>
<li>O - Output using Pull Push Drivers</li>
<li>PP - I/O using Pull Push Drivers</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Pin #</th>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>CD/DAT3</td>
          <td>I/O/PP</td>
          <td>Card Detect/Data Line [Bit3]</td>
      </tr>
      <tr>
          <td>2</td>
          <td>CMD</td>
          <td>I/O/PP</td>
          <td>Command/Response</td>
      </tr>
      <tr>
          <td>3</td>
          <td>VSS1</td>
          <td>S</td>
          <td>Supply voltage ground</td>
      </tr>
      <tr>
          <td>4</td>
          <td>VDD</td>
          <td>S</td>
          <td>Supply voltage</td>
      </tr>
      <tr>
          <td>5</td>
          <td>CLK</td>
          <td>I</td>
          <td>Clock</td>
      </tr>
      <tr>
          <td>6</td>
          <td>VSS2</td>
          <td>S</td>
          <td>Supply voltage ground</td>
      </tr>
      <tr>
          <td>7</td>
          <td>DAT0</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit0]</td>
      </tr>
      <tr>
          <td>8</td>
          <td>DAT1</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit1]</td>
      </tr>
      <tr>
          <td>9</td>
          <td>DAT2</td>
          <td>I/O/PP</td>
          <td>Data Line [Bit2]</td>
      </tr>
  </tbody>
</table>
<p>Below is the SD card we studied: an SDSC card (maximum 2GB). It is printed with ‚ÄúM2B9 2GB Made in Japan‚Äù; these markings don‚Äôt seem searchable online.</p>
<p><img loading="lazy"  src="./SD_card_internal.jpg"
        alt="SD_card_internal"/></p>
<p>Now look at the SD controller chip, ‚Äú56X31B002 AC00145R‚Äù, also not searchable.
However, the memory chip below has a Micron logo. On the <a href="https://www.micron.com/decoder"target="_blank" rel="noopener noreferrer">FBGA &amp; Component Marking Decoder</a> website you can query the FBGA code. It is an SLC NAND Flash in a VBGA100 package, but the official information is not very accurate‚Äîonly a 16GB version is listed.</p>
<p><img loading="lazy"  src="./SD_card_internal2.jpg"
        alt="SD_card_internal2"/></p>
<h2 id="registers">Registers</h2>
<p>OCR, CID, CSD, and SCR carry card-specific information; RCA and DSR store the actual configuration parameters; SSR and CSR carry status information.
Because the spec authors seem a bit obsessive, the registers are all three-letter abbreviations; if three letters can‚Äôt express the meaning precisely, they drop the ‚ÄúR‚Äù.</p>
<table>
  <thead>
      <tr>
          <th>Name</th>
          <th>length(bit)</th>
          <th>Description</th>
          <th>Optional</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>CID</td>
          <td>128</td>
          <td>Card Identification Data, includes Manufacturer ID, OEM ID, Product Name, Product Revision, Manufacturing Date, and checksum</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>RCA</td>
          <td>16</td>
          <td>Relative Card Address, used for addressing; default 0x0000; not available in SPI mode</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>DSR</td>
          <td>16</td>
          <td>Driver Stage Register, used to improve bus performance</td>
          <td>Optional</td>
      </tr>
      <tr>
          <td>CSD</td>
          <td>128</td>
          <td>Card Special Data, complex; includes operating conditions such as error types, maximum data access time, speed, DSR availability, etc.</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>SCR</td>
          <td>64</td>
          <td>SD Configuration Register, includes supported features and spec version</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>OCR</td>
          <td>32</td>
          <td>Operation Condition Register, carries current power information</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>SSR</td>
          <td>512</td>
          <td>SD Status Register, carries current SD card characteristics and application-specific status info such as bus width, security mode, card type, speed, etc.</td>
          <td>Required</td>
      </tr>
      <tr>
          <td>CSR</td>
          <td>32</td>
          <td>Card Status Register, carries the status when executing commands (reflected in responses), such as lock state and error info</td>
          <td>Required</td>
      </tr>
  </tbody>
</table>
<h2 id="architecture">Architecture</h2>
<p>The card contains a power-on detection circuit connected to both the host interface and the storage-area interface. Each pin connects to the card controller, and the controller operates on the storage area via the storage interface.</p>
<p><img loading="lazy"  src="./architecture.png"
        alt="architecture"/></p>
<h3 id="sdio">SDIO</h3>
<p>In the SDIO specification, two types of SDIO cards are defined: low-speed cards and high-speed cards. Three modes are defined for SDIO cards:</p>
<ul>
<li>SPI bus mode</li>
<li>One-bit SD bus mode - command and data are separated</li>
<li>Four-bit SD bus mode - supported by high-speed cards; commands occupy a dedicated channel while the other 4 channels transfer data; this is the default SD mode</li>
</ul>
<h2 id="sd-bus-protocol">SD Bus Protocol</h2>
<p>SD bus communication mainly consists of CMD (Command Token, operation command) and DAT (data). CMD and DAT are transmitted in parallel on different channels. CMD and Response share the same channel: CMD comes from the host, Response comes from the SD card, and a Response appears only for specific CMDs.</p>
<p><img loading="lazy"  src="./sd_protocal.png"
        alt="sd_protocal"/></p>
<p>SD specifies block-based read/write operations; the data block follows the CMD. Each data block ends with CRC bits. Termination of an operation is done by sending a terminate command.</p>
<p><img loading="lazy"  src="./sd_protocal_r.png"
        alt="sd_protocal_r"/></p>
<p>The write process includes a busy signal.</p>
<p><img loading="lazy"  src="./sd_protocal_w.png"
        alt="sd_protocal_w"/></p>
<h3 id="cmd-format">CMD Format</h3>
<p>The Command Token length is 48 bits. The start bit is 0. The transmission bit is 1, indicating data from the host. Content carries the command, address information, and parameters. It ends with a 7-bit CRC (Cyclic Redundancy Check), and the end bit is 0. Because of this property, the first byte of a Response is 0x40 smaller than the first byte of a CMD.</p>
<p><img loading="lazy"  src="./cmd_format.png"
        alt="cmd_format"/></p>
<p>There are four response token scenarios. Depending on the scenario, different lengths are used: 48-bit (R1, R3, R6) and 136-bit (R2). The transmission bit is 0, indicating data from the SD card.</p>
<p><img loading="lazy"  src="./response_format.png"
        alt="response_format"/></p>
<h3 id="data-packet-format">Data Packet Format</h3>
<p>In normal mode, data is transmitted via DAT[0-3]. Like CMD, it has a start bit 0, an end bit 1, and CRC. The default bus width is 1-bit.</p>
<p><img loading="lazy"  src="./data_packet_format.png"
        alt="data_packet_format"/></p>
<h3 id="crc7">CRC7</h3>
<p>SD cards use the CRC7/MMC algorithm for CMD checking. The formula is:</p>
<p><img loading="lazy"  src="./crc7_calc.png"
        alt="crc7_calc"/></p>
<p>Convert the polynomial to binary G(x):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">10001001
</span></span></code></pre></div><p>Append (divisor-1) bits (i.e., 7) to the data frame M(x), then perform modulo-2 division: divide the data frame by 10001001 to obtain the CRC.</p>
<p><img loading="lazy"  src="./crc7.png"
        alt="crc7"/></p>
<h3 id="crc16">CRC16</h3>
<p>SD cards use CRC-16/CCITT-XMODEM for Data checking. In wide-bus mode, each line computes CRC independently. The formula is:</p>
<p><img loading="lazy"  src="./crc16_calc.png"
        alt="crc16_calc"/></p>
<p>Convert the polynomial to binary G(x); the 16th bit exceeds the length and is ignored:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">0001000000100001
</span></span></code></pre></div><p><img loading="lazy"  src="./crc16.png"
        alt="crc16"/></p>
<h2 id="response-type">Response Type</h2>
<p>There are five types of SD card responses; SDIO supports additional response types R4 and R5. Except for R3, response packets end with CRC.</p>
<ul>
<li>R1 Normal response; may carry a busy signal (R1b)</li>
<li>R2 CID/CSD response</li>
<li>R3 OCR response</li>
<li>R6 RCA response</li>
<li>R7 Card interface condition response</li>
</ul>
<h3 id="formats-for-different-response-types">Formats for different response types</h3>
<p>The parameter field of R1 is 32 bits and corresponds to card status. Due to version iteration, the spec doesn‚Äôt explicitly call it CSR, and the CSR register was defined later. R2 directly returns CID or CSD data. R3 returns OCR data.</p>
<p><img loading="lazy"  src="./response_r1.png"
        alt="response_r1"/>
<img loading="lazy"  src="./response_r2.png"
        alt="response_r2"/>
<img loading="lazy"  src="./response_r3.png"
        alt="response_r3"/>
<img loading="lazy"  src="./response_r6.png"
        alt="response_r6"/>
<img loading="lazy"  src="./response_r7.png"
        alt="response_r7"/></p>
<h2 id="function-mode">Function mode</h2>
<p>There are two operating modes for SD cards; by default the card is inactive:</p>
<ul>
<li>card indentification mode</li>
<li>data transfer mode</li>
</ul>
<p>Under UHS-II and SD mode, the card identification mode differs.</p>
<h2 id="command">Command</h2>
<p>Commands are mainly of two types‚Äîbroadcast and addressed. More specifically, there are four categories:</p>
<ul>
<li>broadcast commands (bc), no response</li>
<li>broadcast commands with response (bcr) (Note: No open drain on SD card)</li>
<li>addressed (point-to-point) commands (ac), no data transfer on DAT lines</li>
<li>addressed (point-to-point) data transfer commands (adtc), data transfer on DAT lines</li>
</ul>
<p>CMD5 and CMD52-54 are SDIO-specific.</p>
<p>Most Significant Bit (MSB) comes first; Least Significant Bit (LSB) comes last.</p>
<p><img loading="lazy"  src="./command_format.png"
        alt="command_format"/></p>
<p>Classes are categorized as follows:</p>
<table>
  <thead>
      <tr>
          <th>Class #</th>
          <th>Name</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>Basic Commands</td>
      </tr>
      <tr>
          <td>1</td>
          <td>Command and Queue Function Commands</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Block Oriented Read Commands</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Reversed</td>
      </tr>
      <tr>
          <td>4</td>
          <td>Block Oriented Write Commands</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Erase Commands</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Block Oriented Write Protection Commands</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Lock Card</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Application Specific Commands</td>
      </tr>
      <tr>
          <td>9</td>
          <td>I/O Mode Commands</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Switch Function Commands</td>
      </tr>
      <tr>
          <td>11</td>
          <td>Function Extension Commands</td>
      </tr>
  </tbody>
</table>
<p>There are three ‚ÄúClass 7‚Äù commands related to card locking. CMD16 sets the block length and is used for setting the password. CMD42 performs lock/unlock. A locked card can respond to Class 0 commands.</p>
<p><img loading="lazy"  src="./card_lock_class.png"
        alt="card_lock_class"/></p>
<p>For SDSC cards, <code>SET_BLOCK_LEN</code> can be used to specify the data block length. For SDHC and SDXC cards, the block length is fixed at 512 bytes.</p>
<h2 id="application-specific-commands">Application-Specific Commands</h2>
<p>Application-Specific Commands extend Commands. CMD55 is the condition to trigger ACMD; ACMD41 is CMD55 followed by CMD41.</p>
<p>ACMD41 is the initialization command and sets HCS (Host Capacity Support), determining SD card type, power control, and voltage levels. ACMD6 sets the bus width, choosing 1-bit or 4-bit data transfer. Only unlocked cards in transfer state can use ACMD6.</p>
<h2 id="status-information">Status Information</h2>
<p>SD card status information can be seen in R1-type responses, e.g., CMD13. SD cards have three kinds of status information:</p>
<ul>
<li>SD Status</li>
<li>Card Status</li>
<li>Task Status</li>
</ul>
<p>Below are the type definitions for each bit:</p>
<p>E - Error bit
S - Status bit
R - Detected and set for the actual command response
X - Detected and set during command execution. The host can obtain status info from command responses</p>
<p>And the clear conditions for status bits:</p>
<p>A - According to the card current status.
B - Always related to the previous command. Cleared by sending specific CMDs
C - Clear by read.</p>
<p>R1 responses carry card status information. The length is 32 bits and is stored in CSR. Below is the definition of each CSR bit (reserved bits omitted).</p>
<table>
  <thead>
      <tr>
          <th>Bits</th>
          <th>Identifier</th>
          <th>Type</th>
          <th>Value</th>
          <th>Description</th>
          <th>Clear Condition</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>31</td>
          <td>OUT_OF_RANGE</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The command&rsquo;s argument was out of the allowed range for this card.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>30</td>
          <td>ADDRESS_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>A misaligned address which did not match the block length was used in the command.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>29</td>
          <td>BLOCK_LEN_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The transferred block length is not allowed for this card, or the number of transferred bytes does not match the block length.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>28</td>
          <td>ERASE_SEQ_ERROR</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>An error in the sequence of erasecommands occurred.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>27</td>
          <td>ERASE_PARAM</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>An invalid selection of write-blocksfor erase occurred.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>26</td>
          <td>WP_VIOLATION</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no protected<br/>&lsquo;1&rsquo;= protected</td>
          <td>Set when the host attempts to writeto a protected block or to the temporary or permanent write protected card.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>25</td>
          <td>CARD_IS_LOCKED</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= card unlocked<br/>&lsquo;1&rsquo;= card locked</td>
          <td>When set, signals that the card is locked by the host.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>24</td>
          <td>LOCK_UNLOCK_FAILED</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Set when a sequence or passworderror has been detected in lock/unlock card command.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>23</td>
          <td>COM_CRC_ERROR</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>The CRC check of the previous command failed.</td>
          <td>B</td>
      </tr>
      <tr>
          <td>22</td>
          <td>ILLEGAL_COMMAND</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Command not legal for the cardstate</td>
          <td>B</td>
      </tr>
      <tr>
          <td>21</td>
          <td>CARD_ECC_FAILED</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Card internal ECC was applied butfailed to correct the data.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>20</td>
          <td>CC_ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Internal card controller error.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>19</td>
          <td>ERROR</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>A general or an unknown error occurred during the operation.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>16</td>
          <td>CSD_OVERWRITE</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Can be either one of the following errors: <br/>- The read only section of the CSD does not match the card content. <br/>- An attempt to reverse the copy (set as original) or permanent WP (unprotected) bits was made.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>15</td>
          <td>WP_ERASE_SKIP</td>
          <td>E R X</td>
          <td>&lsquo;0&rsquo;= no protected<br/>&lsquo;1&rsquo;= protected</td>
          <td>Set when only partial address space was erased due to existing write protected blocks or the temporary or permanent write protected card was erased.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>14</td>
          <td>CARD_ECC_DISABLED</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= enabled<br/>&lsquo;1&rsquo;= disabled</td>
          <td>The command has been executed without using the internal ECC.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>13</td>
          <td>ERASE_RESET</td>
          <td>S R</td>
          <td>&lsquo;0&rsquo;= cleared<br/>&lsquo;1&rsquo;= set</td>
          <td>An erase sequence was cleared before executing because an out of erase sequence command was received.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>12:9</td>
          <td>CURRENT_STATE</td>
          <td>S X</td>
          <td>0 = idle<br/>1 = ready<br/>2 = ident<br/>3 = stby<br/>4 = tran<br/>5 = data<br/>6 = rcv<br/>7 = prg<br/>8 = dis<br/>9-14 = reserved<br/>15 = reserved for<br/>I/O mode</td>
          <td>The state of the card when receiving the command. If the command execution causes a state change, it will be visible to the host in the response to the next command.<br/> The four bits are interpreted as a binary coded number between 0 and 15.</td>
          <td>B</td>
      </tr>
      <tr>
          <td>8</td>
          <td>READY_FOR_DATA</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= not ready<br/>&lsquo;1&rsquo;= ready</td>
          <td>Corresponds to buffer empty signaling on the bus.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>6</td>
          <td>FX_EVENT</td>
          <td>S X</td>
          <td>&lsquo;0&rsquo;= No event<br/>&lsquo;1&rsquo;= Event invoked</td>
          <td>Extension Functions may set this bit to get host to deal with events.</td>
          <td>A</td>
      </tr>
      <tr>
          <td>5</td>
          <td>APP_CMD</td>
          <td>S R</td>
          <td>&lsquo;0&rsquo;= enabled<br/>&lsquo;1&rsquo;= disabled</td>
          <td>The card will expect ACMD, or an indication that the command has been interpreted as ACMD.</td>
          <td>C</td>
      </tr>
      <tr>
          <td>3</td>
          <td>AKE_SEQ_ERROR(SD Memory Card app. spec.)</td>
          <td>E R</td>
          <td>&lsquo;0&rsquo;= no error<br/>&lsquo;1&rsquo;= error</td>
          <td>Error in the sequence of the authentication process.</td>
          <td>C</td>
      </tr>
  </tbody>
</table>
<p><code>12:9</code> is 4 bits long. Converting to decimal corresponds to the card‚Äôs operating stage:</p>
<p><img loading="lazy"  src="./state_mode.png"
        alt="state_mode"/></p>
<h2 id="sd-protocol-sniff">SD Protocol Sniff</h2>
<p>Length matching is a PCB design term, commonly used for high-speed I/O such as DDR. When using fly-wires, try to keep equal lengths and control the distance between the clock line and other signal lines‚Äîthis is also an SD card vendor requirement for PCB design.</p>
<p><img loading="lazy"  src="./wiring.jpg"
        alt="wiring"/></p>
<p>In practice, SD ‚Äúhigh-speed‚Äù mode is only 20MHz, so whether you use length-matched routing doesn‚Äôt have much impact on data. The most critical factor is the sampling rate of the logic analyzer. At the beginning, a 100MHz sampling-rate logic analyzer often produced garbage; after switching to an LA5016 at 500MHz, it worked normally.</p>
<p><img loading="lazy"  src="./LA5016.jpg"
        alt="LA5016"/></p>
<p>Choose the sampling rate and time, and also select the voltage level. Select SDIO and trigger on the clock rising edge. This yields accurate logic levels. As shown below, the data corresponding to the rising edge is 0.</p>
<p><img loading="lazy"  src="./rising_edge.png"
        alt="rising_edge"/></p>
<h2 id="sd-unlock">SD Unlock</h2>
<p>The unlock session is only effective within a single power cycle; on the next power-up, the SD card automatically returns to the locked state. The unlock flow first uses CMD7 to select the card. If FEP is set, you need to unlock COP. Then use CMD16 to set the required block length: 8-bit unlock operation + 8-bit password length + the actual password length. Finally, send CMD42 to unlock.</p>
<p><img loading="lazy"  src="./unlock_operations.png"
        alt="unlock_operations"/></p>
<h3 id="cmd-42">CMD 42</h3>
<p>CMD42 is used to unlock the device, with two versions: V1.0 and V2.0. There are also two unlocking methods: force erase password (Force Erase Password, FEP), and password-based unlock. Only SD cards with the COP (Card Ownership Protection) feature have a non-volatile FEP register. COP is newly added in SD spec 6.0, and SD cards with COP are rare on the market.</p>
<p>From the CMD format, <code>01</code> indicates a CMD request, <code>101010</code> represents 42, so the first byte of CMD42 should be <code>01101010</code>, i.e. <code>6A</code>.
The first 4 bits of CMD42‚Äôs argument should be 0. The corresponding CSR status bit-25 should change from 1 to 0, and bit-24 should be 0.</p>
<p><img loading="lazy"  src="./unlock_parameters.png"
        alt="unlock_parameters"/></p>
<p>By decoding the communication between the host and the SD card with a logic analyzer, I obtained the following frame. The Command Index, Arguments, and CRC7 all match the definitions above.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">6A 00 00 00 00 51
</span></span></code></pre></div><p>The last byte <code>51</code> can be validated via CRC7.</p>
<p>The target device studied in this post is relatively old and does not support COP. In the lock/unlock bit, <code>0</code> indicates unlock and <code>1</code> indicates lock. Since we use CMD42, the operation parameter is <code>00000000</code>, i.e. <code>CMD42[00h]</code>.</p>
<p>For the Data portion of CMD42: the first byte describes the operation. The first three bits are reserved and are typically set to 0. The fourth bit indicates the COP feature. During unlock, the remaining four bits should all be 0. The second byte is the password length field, 8 bits wide, in bytes. Therefore the maximum password length is 128 bytes. Here the password length is 16 bytes. Starting from the third byte is the password data, and finally a 16-bit CRC is appended.</p>
<p><img loading="lazy"  src="./password.png"
        alt="password"/></p>
<p>The address in CMD7 is random:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">47 4B 47 00 00 6F
</span></span><span class="line"><span class="cl">[47:41] 01000111  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 01001011  RCA 4B
</span></span><span class="line"><span class="cl">[31:24] 01000111  RCA 47
</span></span><span class="line"><span class="cl">[23:16] 00000000  stuff bits
</span></span><span class="line"><span class="cl">[15:8]  00000000
</span></span><span class="line"><span class="cl">[7:0]   01101111  CRC7 + end bit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">07 02 00 07 00 79
</span></span></code></pre></div><p>CMD16 is as follows. The second-to-last line is the <code>SET_BLOCKLEN</code> argument, which sets the block length and must be an even length. The response type is R1. <code>0b00010010</code> is 18 in decimal, i.e. 2 bytes of parameters plus a 16-byte password.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">50 00 00 00 12 2F
</span></span><span class="line"><span class="cl">[47:41] 01010000  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 00000000
</span></span><span class="line"><span class="cl">[31:24] 00000000
</span></span><span class="line"><span class="cl">[23:16] 00000000
</span></span><span class="line"><span class="cl">[15:8]  00010010  SET_BLOCKLEN
</span></span><span class="line"><span class="cl">[7:0]   00101111  CRC7 + end bit
</span></span></code></pre></div><p>CMD16 response:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">10 02 00 09 00 07
</span></span><span class="line"><span class="cl">[47:41] 00010000  start bit + Command index
</span></span><span class="line"><span class="cl">[40:32] 00000010  Card Status
</span></span><span class="line"><span class="cl">[31:24] 00000000  Card Status
</span></span><span class="line"><span class="cl">[23:16] 00001001  Card Status
</span></span><span class="line"><span class="cl">[15:8]  00000000  Card Status
</span></span><span class="line"><span class="cl">[7:0]   00000111  CRC7 + end bit
</span></span></code></pre></div><p>The first byte of the CMD42 response is <code>00101010</code>, i.e. <code>2A</code>. The response type is R1.</p>
<p>I captured the CMD42 response using a logic analyzer.</p>
<p>Convert the Parameter field to binary. According to the CSR definition, the status below indicates: not unlocked, ready, tran mode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">2a <span class="m">02</span> <span class="m">00</span> <span class="m">09</span> <span class="m">00</span> 6f
</span></span><span class="line"><span class="cl"><span class="o">[</span>47:41<span class="o">]</span> <span class="m">00010000</span>  start bit + Command index
</span></span><span class="line"><span class="cl"><span class="o">[</span>40:32<span class="o">]</span> <span class="m">00000010</span>  Card Status Locked
</span></span><span class="line"><span class="cl"><span class="o">[</span>31:24<span class="o">]</span> <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>23:16<span class="o">]</span> <span class="m">00001001</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>15:8<span class="o">]</span>  <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>7:0<span class="o">]</span>   <span class="m">00000111</span>  CRC7 + end bit
</span></span></code></pre></div><p>After CMD42 Data is sent, send CMD13. According to CSR, the status below indicates: unlocked, ready, tran mode, APP_CMD disabled.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">0D <span class="m">00</span> <span class="m">00</span> <span class="m">09</span> <span class="m">00</span> <span class="m">07</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>47:41<span class="o">]</span> <span class="m">00010000</span>  start bit + Command index
</span></span><span class="line"><span class="cl"><span class="o">[</span>40:32<span class="o">]</span> <span class="m">00000000</span>  Card Status Unlocked
</span></span><span class="line"><span class="cl"><span class="o">[</span>31:24<span class="o">]</span> <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>23:16<span class="o">]</span> <span class="m">00001001</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>15:8<span class="o">]</span>  <span class="m">00000000</span>  Card Status
</span></span><span class="line"><span class="cl"><span class="o">[</span>7:0<span class="o">]</span>   <span class="m">01101111</span>  CRC7 + end bit
</span></span></code></pre></div><h3 id="analyze-data">Analyze Data</h3>
<p>In KingstVIS, locate the Data0 channel. Align to the rising edge after CMD42, select the interval, and export the clock channel and Data0 channel as TXT.</p>
<p><img loading="lazy"  src="./exporting_data.png"
        alt="exporting_data"/></p>
<p>The exported data is actually still CSV. In KingstVIS, exporting as CSV results in reversed order, so TXT format was chosen. The character encoding is ANSI; it will appear garbled on Linux, so remove the Title line.</p>
<p><img loading="lazy"  src="./csv_data_exported.png"
        alt="csv_data_exported"/></p>
<p>With the script below, you can print the Data0 data into readable output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -*- coding: utf-8 -*-</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">csv</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">getopt</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">binascii</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">parse_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_ch0_v</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="n">bits</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">current_ch0_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">current_ch0_v</span> <span class="o">^</span> <span class="n">last_ch0_v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">last_ch0_v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">bits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
</span></span><span class="line"><span class="cl">                <span class="n">last_ch0_v</span> <span class="o">=</span> <span class="n">current_ch0_v</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">bits</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">crc16_calc</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">crc</span> <span class="o">=</span> <span class="mh">0x0000</span>
</span></span><span class="line"><span class="cl">    <span class="n">poly</span> <span class="o">=</span> <span class="mh">0x1021</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur_byte</span> <span class="o">=</span> <span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">bit</span> <span class="o">=</span> <span class="p">((</span><span class="n">cur_byte</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">7</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">c15</span> <span class="o">=</span> <span class="p">((</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">crc</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">c15</span> <span class="o">^</span> <span class="n">bit</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">crc</span> <span class="o">^=</span> <span class="n">poly</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">usage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s2">&#34;f:o&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">csv_file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">output_file</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">opt</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;-f&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">csv_file</span> <span class="o">=</span> <span class="n">arg</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;-o&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">output_file</span> <span class="o">=</span> <span class="n">arg</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">bits</span> <span class="o">=</span> <span class="n">parse_csv</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">keys_list</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="n">crc_data</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="n">keys_len</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># ÂéªÊéâDataÁöÑÁ¨¨‰∏Ä‰ΩçÊ†áÂøó‰Ωç</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="mi">8</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="n">byte</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> \
</span></span><span class="line"><span class="cl">                    <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">8</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CMD42 data block parameters error.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Keys length: &#34;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">keys_len</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;-bytes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                    <span class="n">keys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">elif</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">keys_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                    <span class="n">crc_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">crc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="n">crc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">crc16_calc</span><span class="p">(</span><span class="n">keys_list</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                        <span class="n">x</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">keys_list</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">keys_len</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Key:&#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">2</span><span class="p">:(</span><span class="n">keys_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CRC:&#34;</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="n">crc16_calc</span><span class="p">(</span><span class="n">keys_list</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">Analyse compeleted!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;CRC error!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">exit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Data Error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">usage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">usage</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Usage:python kinstvis_sdio_parser.py -f test.csv&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>Remove the first start bit, parse the CMD42 Data structure, and then verify CRC; the CRC check succeeds.</p>
<p><img loading="lazy"  src="./parse_key.png"
        alt="parse_key"/></p>
<p>The password is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">5ffca19ffcdb5899a82c4e265f99c76b
</span></span></code></pre></div><h2 id="mmc-utils">MMC Utils</h2>
<p>The next step is to write an SD unlock tool. Micron‚Äôs official documentation provides a demo for adding lock/unlock functionality; by modifying <code>mmc-utils</code> you can implement unlocking.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc-utils.git
</span></span></code></pre></div><p><code>mmc-utils/mmc.h</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define MMC_SET_BLOCKLEN        16 </span><span class="cm">/* ac [31:0] block len R1 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_UNLOCK         42 </span><span class="cm">/* adtc R1b */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_UNLOCK        0x0 </span><span class="cm">/* UNLOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_SET_PWD       0x1 </span><span class="cm">/* SET_PWD */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_CLR_PWD       0x2 </span><span class="cm">/* CLR_PWD */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_LOCK          0x4 </span><span class="cm">/* LOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_SET_LOCK      0x5 </span><span class="cm">/* SET_PWD &amp; LOCK */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CMD42_ERASE         0x8 </span><span class="cm">/* ERASE */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_PWD_LENGTH          32 </span><span class="cm">/* max PWDS_LEN: old+new */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_BLOCK_SIZE          512 </span><span class="cm">/* data blk size for cmd42 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_R1_ERROR            (1 &lt;&lt; 19) </span><span class="cm">/* R1 bit19 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_R1_LOCK_ULOCK_FAIL  (1 &lt;&lt; 24) </span><span class="cm">/* R1 bit24 */</span><span class="cp">
</span></span></span></code></pre></div><p><code>mmc-utils/mmc.c</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">{</span><span class="n">do_lock_unlock</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;cmd42&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;password&gt; &lt;s|c|l|u|e&gt; &lt;device&gt;</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;s</span><span class="se">\t</span><span class="s">set password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;c</span><span class="se">\t</span><span class="s">clear password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;l</span><span class="se">\t</span><span class="s">lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;sl</span><span class="se">\t</span><span class="s">set password and lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;u</span><span class="se">\t</span><span class="s">unlock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;e</span><span class="se">\t</span><span class="s">force erase</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nb">NULL</span><span class="p">},</span>
</span></span></code></pre></div><p><code>mmc-utils/mmc_cmds.h</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//lock/unlock feature implementation
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">do_lock_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">nargs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u8</span> <span class="n">data_block</span><span class="p">[</span><span class="n">MMC_BLOCK_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u8</span> <span class="n">data_block_onebyte</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_ioc_cmd</span> <span class="n">idata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmd42_para</span><span class="p">;</span>               <span class="c1">//parameter of cmd42
</span></span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">pwd</span><span class="p">[</span><span class="n">MAX_PWD_LENGTH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">//password
</span></span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pwd_len</span><span class="p">;</span>                  <span class="c1">//password length
</span></span></span><span class="line"><span class="cl">    <span class="n">__u32</span> <span class="n">r1_response</span><span class="p">;</span>            <span class="c1">//R1 response token
</span></span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">nargs</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Usage: mmc cmd42 &lt;password&gt; &lt;s|c|l|u|e&gt; &lt;device&gt; </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">strcpy</span><span class="p">(</span><span class="n">pwd</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pwd_len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_SET_PWD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set password: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_CLR_PWD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Clear password: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;l&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_LOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Lock the card: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;sl&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_SET_LOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set password and lock the card: password - %s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;u&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_UNLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Unlock the card: password=%s ...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pwd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">strcmp</span><span class="p">(</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmd42_para</span> <span class="o">=</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Force erase ... (Warning: all card data will be erased together with PWD!)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Invalid parameter:</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;s</span><span class="se">\t</span><span class="s">set password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;c</span><span class="se">\t</span><span class="s">clear password</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;l</span><span class="se">\t</span><span class="s">lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;sl</span><span class="se">\t</span><span class="s">set password and lock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;u</span><span class="se">\t</span><span class="s">unlock</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">               <span class="s">&#34;e</span><span class="se">\t</span><span class="s">force erase</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">device</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">nargs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;open&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//set blk size to 2-byte for Force Erase @DDR50 compability
</span></span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">MMC_BLOCK_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">set_block_len</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span> <span class="c1">//set data block size prior to cmd42
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Set to data block length = %d byte(s).</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block_onebyte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd42_para</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd42_para</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">data_block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwd_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">data_block</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pwd</span><span class="p">,</span> <span class="n">pwd_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">idata</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">write_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_LOCK_UNLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//set all 0 for cmd42 arg
</span></span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span> <span class="o">|</span> <span class="n">MMC_CMD_ADTC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">blksz</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cmd42_para</span> <span class="o">==</span> <span class="n">MMC_CMD42_ERASE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mmc_ioc_cmd_set_data</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">data_block_onebyte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mmc_ioc_cmd_set_data</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">data_block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">MMC_IOC_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idata</span><span class="p">);</span> <span class="c1">//Issue CMD42
</span></span></span><span class="line"><span class="cl">    <span class="n">r1_response</span> <span class="o">=</span> <span class="n">idata</span><span class="p">.</span><span class="n">response</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;cmd42 response: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_ERROR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">//check CMD42 error
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;cmd42 error! Error code: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_ERROR</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_LOCK_ULOCK_FAIL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//check lock/unlock error
</span></span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Card lock/unlock fail! Error code: 0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r1_response</span> <span class="o">&amp;</span> <span class="n">MMC_R1_LOCK_ULOCK_FAIL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//change data block length
</span></span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">set_block_len</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blk_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_ioc_cmd</span> <span class="n">idata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">idata</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_SET_BLOCKLEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">blk_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idata</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">MMC_IOC_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idata</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In practice this is controlled via <code>ioctl</code>. After compiling, I could lock the card, but I could never successfully unlock it again‚Äîso I had to try another approach.</p>
<p><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/mmc/ioctl.h"target="_blank" rel="noopener noreferrer">https://github.com/torvalds/linux/blob/master/include/uapi/linux/mmc/ioctl.h</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo ./mmc scr <span class="nb">read</span> /sys/bus/mmc/devices/mmc0:aaaa/
</span></span><span class="line"><span class="cl">type: <span class="s1">&#39;SD&#39;</span>
</span></span><span class="line"><span class="cl">version: SD 3.0x
</span></span><span class="line"><span class="cl">bus widths: 4bit, 1bit,
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo ./mmc cmd42 <span class="m">123456</span> s /sys/bus/mmc/devices/mmc0:aaaa/
</span></span><span class="line"><span class="cl">Set password: <span class="nv">password</span><span class="o">=</span><span class="m">123456</span> ...
</span></span></code></pre></div><h2 id="modify-the-kernel-module">Modify the kernel module</h2>
<p>Since third-party tools couldn‚Äôt achieve it, I had to modify the kernel module. My OS was Arch Linux; the MMC driver is a kernel module, so I didn‚Äôt need to rebuild the whole kernel (unlike Ubuntu where it is often built-in).</p>
<p>The kernel module directories on Arch Linux are as follows. My laptop is an HP 840G3. The SD card uses the PCI bus, and the following drivers are involved:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/core/mmc_core.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/core/mmc_block.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/mmc/host/rtsx_pci_sdmmc.ko.xz
</span></span><span class="line"><span class="cl">/lib/modules/$(uname -r)/kernel/drivers/misc/cardreader/rtsx_pci.ko.xz
</span></span></code></pre></div><p>If you re-download the official source and build the kernel module, you may encounter strange errors. First is the <code>vermagic</code> matching issue: if the kernel version and CPU features don‚Äôt match, the module cannot be loaded. Because Linux added a module signing mechanism after 3.7, you can use <code>modinfo</code> to inspect the system‚Äôs built-in modules; missing signatures can also prevent loading.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ modinfo mmc_core
</span></span><span class="line"><span class="cl">filename:       /lib/modules/4.18.10-arch1-1-ARCH/kernel/drivers/mmc/core/mmc_core.ko.xz
</span></span><span class="line"><span class="cl">license:        GPL
</span></span><span class="line"><span class="cl">srcversion:     72D2DBEB18AB4B898BE5331
</span></span><span class="line"><span class="cl">depends:
</span></span><span class="line"><span class="cl">retpoline:      Y
</span></span><span class="line"><span class="cl">intree:         Y
</span></span><span class="line"><span class="cl">name:           mmc_core
</span></span><span class="line"><span class="cl">vermagic:       4.18.10-arch1-1-ARCH SMP preempt mod_unload modversions
</span></span><span class="line"><span class="cl">sig_id:         PKCS#7
</span></span><span class="line"><span class="cl">signer:
</span></span><span class="line"><span class="cl">sig_key:
</span></span><span class="line"><span class="cl">sig_hashalgo:   md4
</span></span><span class="line"><span class="cl">signature:      30:82:02:A5:06:09:2A:86:48:86:F7:0D:01:07:02:A0:82:02:96:30
</span></span><span class="line"><span class="cl">                ‰ª•‰∏ãÁúÅÁï•
</span></span><span class="line"><span class="cl">parm:           use_spi_crc:bool
</span></span></code></pre></div><p>We can build in <code>/usr/lib/modules/$(uname -r)/build/</code> without extra configuration. Just copy the MMC core code into the target directory, then <code>make</code>, and reload the MMC kernel modules.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp ./core/* /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/mmc/core/
</span></span><span class="line"><span class="cl">make modules <span class="nv">SUBDIRS</span><span class="o">=</span>drivers/mmc/core
</span></span><span class="line"><span class="cl">  Building modules, stage 2.
</span></span><span class="line"><span class="cl">  MODPOST <span class="m">7</span> modules
</span></span><span class="line"><span class="cl">rmmod rtsx_pci_sdmmc <span class="o">&amp;&amp;</span> rmmod mmc_core
</span></span><span class="line"><span class="cl">insmod /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/mmc/core/mmc_core.ko
</span></span><span class="line"><span class="cl">insmod /lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/kernel/drivers/mmc/host/rtsx_pci_sdmmc.ko.xz
</span></span></code></pre></div><h3 id="add-unlock-function">Add Unlock Function</h3>
<p>Add the <code>unlock_mmc</code> declaration in <code>mmc_ops.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unlock_mmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">key_buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">key_len</span><span class="p">);</span>
</span></span></code></pre></div><p>Then implement it: first set the block length, then send the CMD42 ADTC command.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unlock_mmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_card</span> <span class="o">*</span><span class="n">card</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">key_buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">key_len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">key_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_request</span> <span class="n">mrq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_command</span> <span class="n">cmd_sbl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_command</span> <span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">mmc_data</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u8</span> <span class="o">*</span><span class="n">data_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*------------CMD 16----------------*/</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1 byteflag + 1 byte password length + 16 bytes password
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_sbl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_command</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_SET_BLOCKLEN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd_sbl</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_AC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="nf">mmc_wait_for_cmd</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_sbl</span><span class="p">,</span> <span class="n">MMC_CMD_RETRIES</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s failed block_size=%d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">,</span><span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*-----------CMD 42-----------------*/</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// CMD
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_command</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MMC_LOCK_UNLOCK</span><span class="p">;</span> <span class="c1">// CMD 42
</span></span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// set all 0 for cmd42 arg
</span></span></span><span class="line"><span class="cl">    <span class="n">cmd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_RSP_R1</span> <span class="o">|</span> <span class="n">MMC_CMD_ADTC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Data
</span></span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">timeout_ns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">blksz</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">MMC_DATA_WRITE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">sg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">sg_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mmc_set_data_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">card</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mmc_request</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">mrq</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mrq</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set Data for DMA
</span></span></span><span class="line"><span class="cl">    <span class="n">data_buf</span> <span class="o">=</span> <span class="nf">kzalloc</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s kzalloc failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">data_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">data_buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// request
</span></span></span><span class="line"><span class="cl">    <span class="nf">mmc_wait_for_req</span><span class="p">(</span><span class="n">card</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mrq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">err</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;%s: unlock cmd error %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cmd</span><span class="p">.</span><span class="n">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[SDLOCK] %s MMC_LOCK_UNLOCK </span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">__func__</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nl">out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kfree</span><span class="p">(</span><span class="n">data_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Before <code>mmc_sd_setup_card</code> in <code>sd.c</code>, add the unlock logic.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">// Ê£ÄÊü•ÊòØÂê¶‰∏äÈîÅ
</span></span><span class="line"><span class="cl">u32 <span class="nv">status</span> <span class="o">=</span> 0<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">err</span> <span class="o">=</span> mmc_send_status<span class="o">(</span>card, <span class="p">&amp;</span>status<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">    goto free_card<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    mmc_card_set_encrypted<span class="o">(</span>card<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    mmc_card_set_locked<span class="o">(</span>card<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">//Êñπ‰æøË∞ÉËØï
</span></span><span class="line"><span class="cl">bool <span class="nv">auto_unlock</span> <span class="o">=</span> true<span class="p">;</span>
</span></span><span class="line"><span class="cl">char unlock_pwd<span class="o">[</span>16<span class="o">]</span> <span class="o">=</span> <span class="o">{</span>0x5f,0xfc,0xa1,0x9f,0xfc,0xdb,0x58,0x99,0xa8,0x2c,0x4e,0x26,0x5f,0x99,0xc7,0x6b<span class="o">}</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="o">(</span>auto_unlock<span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        //unlock sd card
</span></span><span class="line"><span class="cl">        <span class="nv">err</span> <span class="o">=</span> unlock_mmc<span class="o">(</span>card, unlock_pwd, 16<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock failed \n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success \n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="o">(</span>!mmc_card_locked<span class="o">(</span>card<span class="o">))</span>
</span></span><span class="line"><span class="cl">            <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="nv">auto_unlock</span> <span class="o">=</span> false<span class="p">;</span>
</span></span><span class="line"><span class="cl">                printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success and sdcard status is unlocked.\n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="o">{</span>
</span></span><span class="line"><span class="cl">                printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s unlock success but sdcard status is locked, abnormal status.\n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        //Check <span class="k">if</span> card is locked
</span></span><span class="line"><span class="cl">        <span class="nv">err</span> <span class="o">=</span> mmc_send_status<span class="o">(</span>card, <span class="p">&amp;</span>status<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span>err<span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">{</span>
</span></span><span class="line"><span class="cl">            printk<span class="o">(</span><span class="s2">&#34;[SDLOCK] %s resume sd card exception /n&#34;</span>,__func__<span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            goto free_card<span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span>status <span class="p">&amp;</span> R1_CARD_IS_LOCKED<span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard is locked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        goto <span class="k">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="o">{</span>
</span></span><span class="line"><span class="cl">        printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard resume to unlocked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">    printk<span class="o">(</span>KERN_WARNING <span class="s2">&#34;[SDLOCK] sdcard is unlocked\n&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Add macro definitions in <code>card.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define mmc_card_mmc(c)     ((c)-&gt;type == MMC_TYPE_MMC)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_sd(c)      ((c)-&gt;type == MMC_TYPE_SD)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_sdio(c)    ((c)-&gt;type == MMC_TYPE_SDIO)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_locked(c)  ((c)-&gt;state &amp; MMC_STATE_LOCKED)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define mmc_card_encrypt(c) ((c)-&gt;state &amp; MMC_STATE_ENCRYPT)
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_PRESENT        (1&lt;&lt;0)       </span><span class="cm">/* present in sysfs */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_READONLY       (1&lt;&lt;1)       </span><span class="cm">/* card is read-only */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_BLOCKADDR      (1&lt;&lt;2)       </span><span class="cm">/* card uses block-addressing */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CARD_SDXC            (1&lt;&lt;3)       </span><span class="cm">/* card is SDXC */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_CARD_REMOVED         (1&lt;&lt;4)       </span><span class="cm">/* card has been removed */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_DOING_BKOPS    (1&lt;&lt;5)       </span><span class="cm">/* card is doing BKOPS */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_LOCKED         (1&lt;&lt;12)      </span><span class="cm">/* card is currently locked */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_ENCRYPT        (1&lt;&lt;13)      </span><span class="cm">/* card is currently encrypt */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_ULTRAHIGHSPEED (1&lt;&lt;14)      </span><span class="cm">/* card is in ultra high speed mode */</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_SUSPENDED      (1&lt;&lt;6)       </span><span class="cm">/* card is suspended */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_STATE_CMDQ           (1&lt;&lt;7)       </span><span class="cm">/* card is in cmd queue mode */</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_ERASE      (1&lt;&lt;3)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_LOCK       (1&lt;&lt;2)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_CLR_PWD    (1&lt;&lt;1)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_SET_PWD    (1&lt;&lt;0)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MMC_LOCK_MODE_UNLOCK     0
</span></span></span></code></pre></div><p>Add instrumentation in <code>mmc_wait_for_req_done</code> in <code>core.c</code>, then check logs via <code>dmesg</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[mmc] CMD %d err number: %d&#34;</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">mrq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="uhs-i">UHS-I</h2>
<p>UHS-I (Ultra High Speed Phase I) is a bus interface for high-speed data transfer on SDHC and SDXC cards. It supports LVS and has seven operating modes:</p>
<ul>
<li>DS - Default Speed up to 25MHz 3.3V signaling</li>
<li>HS - High Speed up to 50MHz 3.3V signaling</li>
<li>SDR12 - SDR up to 25MHz 1.8V signaling</li>
<li>SDR25 - SDR up to 50MHz 1.8V signaling</li>
<li>SDR50 - SDR up to 100MHz 1.8V signaling</li>
<li>SDR104 - SDR up to 208MHz 1.8V signaling</li>
<li>DDR - DDR up to 50MHz 1.8V signaling</li>
</ul>
<p>First, use CMD0 to select the bus mode: SPI mode or SD mode. The 1.8V signaling mode can only enter SD mode.</p>
<p><img loading="lazy"  src="./uhs_command_sequence.png"
        alt="uhs_command_sequence"/></p>
<p>You can see the unlock did not succeed; CMD42 returned an error <code>-22</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ dmesg -l 0,1,2,3,4,5,6,7
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.072102<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">52</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.175620<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">52</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.177592<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">0</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.181590<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">8</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.282033<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.385534<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.492060<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.595641<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">5</span> err number: -110
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.596514<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.597226<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.626822<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">0</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.630372<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">8</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.631051<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.631758<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.642862<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.643590<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.656036<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.656752<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.669827<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.670711<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.683086<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">55</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.683976<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">41</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.685084<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">2</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.685781<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">3</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.686493<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">13</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.687827<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">9</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.688551<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">7</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.689227<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">16</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690033<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">42</span> err number: -22
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690041<span class="o">]</span> unlock_mmc: unlock cmd error -22
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690045<span class="o">]</span> <span class="o">[</span>SDLOCK<span class="o">]</span> mmc_sd_init_card unlock failed
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690749<span class="o">]</span> <span class="o">[</span>mmc<span class="o">]</span> CMD <span class="m">13</span> err number: <span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690755<span class="o">]</span> <span class="o">[</span>SDLOCK<span class="o">]</span> sdcard is locked
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.690773<span class="o">]</span> mmc0: new SD card at address f317
</span></span><span class="line"><span class="cl"><span class="o">[</span>62696.691709<span class="o">]</span> mmcblk0: mmc0:f317 MF02B 1.88 GiB
</span></span></code></pre></div><p>Linux error number <code>-22</code> is <code>EINVAL</code>. Eventually I traced it to <code>drivers/mmc/host/sdhci.c</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">filename: drivers/mmc/core/core.c
</span></span><span class="line"><span class="cl">functions:
</span></span><span class="line"><span class="cl">mmc_wait_for_req -&gt; __mmc_start_request -&gt; host-&gt;ops-&gt;request
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">filename: drivers/mmc/host/rtsx_pci_sdmmc.c
</span></span><span class="line"><span class="cl">functions:
</span></span><span class="line"><span class="cl">sdmmc_request -&gt; schedule_work -&gt; sd_request -&gt; sd_send_cmd_get_rsp -&gt; sd_normal_rw -&gt; sd_write_data -&gt; rtsx_pci_write_ppbuf -&gt; rtsx_pci_send_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">filename: drivers/misc/cardreader/rtsx_pcr.c
</span></span><span class="line"><span class="cl">rtsx_pci_write_ppbuf
</span></span><span class="line"><span class="cl">rtsx_pci_add_cmd
</span></span><span class="line"><span class="cl">rtsx_pci_send_cmd
</span></span></code></pre></div><p>Because this is a laptop, the relevant commands are in the Realtek SD card reader driver; on phones it is <code>drivers/mfd/rtsx_pcr.c</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rtsx_pci_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtsx_pcr</span> <span class="o">*</span><span class="n">pcr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pcr</span><span class="o">-&gt;</span><span class="n">trans_result</span> <span class="o">==</span> <span class="n">TRANS_RESULT_FAIL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp ./drivers/misc/cardreader/* /usr/lib/modules/<span class="k">$(</span>uname -r<span class="k">)</span>/build/drivers/misc/cardreader/
</span></span><span class="line"><span class="cl">make modules <span class="nv">SUBDIRS</span><span class="o">=</span>drivers/misc/cardreader
</span></span></code></pre></div><p>By printing the parameters of <code>rtsx_pci_add_cmd</code>, I confirmed the key passed in was correct.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sd_cmd_set_sd_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016095] [rtsx] cmd_type:1, reg_addr:fda9, ptr:0x50, val:2108292944 SD_CMD0 16
</span></span><span class="line"><span class="cl">[75754.016100] [rtsx] cmd_type:1, reg_addr:fdaa, ptr:0x0, val:2108358400  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016104] [rtsx] cmd_type:1, reg_addr:fdab, ptr:0x0, val:2108423936  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016111] [rtsx] cmd_type:1, reg_addr:fdac, ptr:0x0, val:2108489472  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016115] [rtsx] cmd_type:1, reg_addr:fdad, ptr:0x12, val:2108555026 SD_CMD4 0x12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_send_cmd_get_rsp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016119] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x1, val:2107768577  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.016122] [rtsx] cmd_type:1, reg_addr:fd5b, ptr:0x1, val:2103116033  CARD_DATA_SOURCE
</span></span><span class="line"><span class="cl">[75754.016126] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x88, val:2108948360  WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.016130] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x60, val:-1112317856 CHECK_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016134] [rtsx] cmd_type:0, reg_addr:fda9, ptr:0x0, val:1034485760  sd_cmd_set_sd_cmd 0
</span></span><span class="line"><span class="cl">[75754.016138] [rtsx] cmd_type:0, reg_addr:fdaa, ptr:0x0, val:1034551296  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016142] [rtsx] cmd_type:0, reg_addr:fdab, ptr:0x0, val:1034616832  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016146] [rtsx] cmd_type:0, reg_addr:fdac, ptr:0x0, val:1034682368  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016150] [rtsx] cmd_type:0, reg_addr:fdad, ptr:0x0, val:1034747904  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016153] [rtsx] cmd_type:0, reg_addr:fda3, ptr:0x0, val:1034092544  SD_STAT1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_cmd_set_sd_cmd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016787] [SDLOCK] unlock_mmc MMC_SET_BLOCKLEN 18
</span></span><span class="line"><span class="cl">[75754.016820] [rtsx] cmd_type:1, reg_addr:fda9, ptr:0x6a, val:2108292970 SD_CMD0 42
</span></span><span class="line"><span class="cl">[75754.016823] [rtsx] cmd_type:1, reg_addr:fdaa, ptr:0x0, val:2108358400  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016826] [rtsx] cmd_type:1, reg_addr:fdab, ptr:0x0, val:2108423936  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016829] [rtsx] cmd_type:1, reg_addr:fdac, ptr:0x0, val:2108489472  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016831] [rtsx] cmd_type:1, reg_addr:fdad, ptr:0x0, val:2108555008  SD_CMD4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016834] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x1, val:2107768577  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.016837] [rtsx] cmd_type:1, reg_addr:fd5b, ptr:0x1, val:2103116033  CARD_DATA_SOURCE
</span></span><span class="line"><span class="cl">[75754.016839] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x88, val:2108948360 WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.016842] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x60, val:-1112317856 CHECK_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.016845] [rtsx] cmd_type:0, reg_addr:fda9, ptr:0x0, val:1034485760  sd_cmd_set_sd_cmd 0
</span></span><span class="line"><span class="cl">[75754.016848] [rtsx] cmd_type:0, reg_addr:fdaa, ptr:0x0, val:1034551296  SD_CMD1
</span></span><span class="line"><span class="cl">[75754.016851] [rtsx] cmd_type:0, reg_addr:fdab, ptr:0x0, val:1034616832  SD_CMD2
</span></span><span class="line"><span class="cl">[75754.016854] [rtsx] cmd_type:0, reg_addr:fdac, ptr:0x0, val:1034682368  SD_CMD3
</span></span><span class="line"><span class="cl">[75754.016856] [rtsx] cmd_type:0, reg_addr:fdad, ptr:0x0, val:1034747904  SD_CMD4
</span></span><span class="line"><span class="cl">[75754.016862] [rtsx] cmd_type:0, reg_addr:fda3, ptr:0x0, val:1034092544  SD_STAT1
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">write data
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017492] [rtsx] cmd_type:1, reg_addr:fa00, ptr:0x0, val:2046885632
</span></span><span class="line"><span class="cl">[75754.017496] [rtsx] cmd_type:1, reg_addr:fa01, ptr:0x10, val:2046951184
</span></span><span class="line"><span class="cl">[75754.017499] [rtsx] cmd_type:1, reg_addr:fa02, ptr:0x5f, val:2047016799
</span></span><span class="line"><span class="cl">[75754.017502] [rtsx] cmd_type:1, reg_addr:fa03, ptr:0xfc, val:2047082492
</span></span><span class="line"><span class="cl">[75754.017505] [rtsx] cmd_type:1, reg_addr:fa04, ptr:0xa1, val:2047147937
</span></span><span class="line"><span class="cl">[75754.017508] [rtsx] cmd_type:1, reg_addr:fa05, ptr:0x9f, val:2047213471
</span></span><span class="line"><span class="cl">[75754.017511] [rtsx] cmd_type:1, reg_addr:fa06, ptr:0xfc, val:2047279100
</span></span><span class="line"><span class="cl">[75754.017513] [rtsx] cmd_type:1, reg_addr:fa07, ptr:0xdb, val:2047344573
</span></span><span class="line"><span class="cl">[75754.017518] [rtsx] cmd_type:1, reg_addr:fa08, ptr:0x58, val:2047410008
</span></span><span class="line"><span class="cl">[75754.017521] [rtsx] cmd_type:1, reg_addr:fa09, ptr:0x99, val:2047475609
</span></span><span class="line"><span class="cl">[75754.017524] [rtsx] cmd_type:1, reg_addr:fa0a, ptr:0xa8, val:2047541160
</span></span><span class="line"><span class="cl">[75754.017526] [rtsx] cmd_type:1, reg_addr:fa0b, ptr:0x2c, val:2047606572
</span></span><span class="line"><span class="cl">[75754.017529] [rtsx] cmd_type:1, reg_addr:fa0c, ptr:0x4e, val:2047672142
</span></span><span class="line"><span class="cl">[75754.017531] [rtsx] cmd_type:1, reg_addr:fa0d, ptr:0x26, val:2047737638
</span></span><span class="line"><span class="cl">[75754.017534] [rtsx] cmd_type:1, reg_addr:fa0e, ptr:0x5f, val:2047803231
</span></span><span class="line"><span class="cl">[75754.017537] [rtsx] cmd_type:1, reg_addr:fa0f, ptr:0x99, val:2047868825
</span></span><span class="line"><span class="cl">[75754.017539] [rtsx] cmd_type:1, reg_addr:fa10, ptr:0xc7, val:2047934407
</span></span><span class="line"><span class="cl">[75754.017542] [rtsx] cmd_type:1, reg_addr:fa11, ptr:0x6b, val:2047999851
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sd_cmd_set_block_len
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017569] [rtsx] cmd_type:1, reg_addr:fdb1, ptr:0x1, val:2108817153  SD_BLOCK_CNT_L 1
</span></span><span class="line"><span class="cl">[75754.017572] [rtsx] cmd_type:1, reg_addr:fdb2, ptr:0x0, val:2108882688  SD_BLOCK_CNT_H
</span></span><span class="line"><span class="cl">[75754.017575] [rtsx] cmd_type:1, reg_addr:fdaf, ptr:0x12, val:2108686098 SD_BYTE_CNT_L  18
</span></span><span class="line"><span class="cl">[75754.017577] [rtsx] cmd_type:1, reg_addr:fdb0, ptr:0x0, val:2108751616  SD_BYTE_CNT_H
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[75754.017580] [rtsx] cmd_type:1, reg_addr:fda1, ptr:0x0, val:2107768576  WRITE_REG_CMD SD_CFG2
</span></span><span class="line"><span class="cl">[75754.017583] [rtsx] cmd_type:1, reg_addr:fdb3, ptr:0x81, val:2108948353 WRITE_REG_CMD SD_TRANSFER
</span></span><span class="line"><span class="cl">[75754.017585] [rtsx] cmd_type:2, reg_addr:fdb3, ptr:0x40, val:-1112326080 CHECK_REG_CMD SD_TRANSFER
</span></span></code></pre></div><h2 id="unlocking-sd-card-by-raspberry-pi">Unlocking SD Card by Raspberry Pi</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo dd <span class="nv">bs</span><span class="o">=</span>4M <span class="k">if</span><span class="o">=</span>/home/cygnus/IMG/2018-06-27-raspbian-stretch-lite/2018-06-27-raspbian-stretch-lite.img <span class="nv">of</span><span class="o">=</span>/dev/mmcblk0 <span class="nv">status</span><span class="o">=</span>progress <span class="nv">conv</span><span class="o">=</span>fsync
</span></span></code></pre></div><p>Download the corresponding Raspberry Pi kernel source, and add the toolchain to the environment variables:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone --depth<span class="o">=</span><span class="m">1</span> --branch rpi-4.14.y https://github.com/raspberrypi/linux
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/home/cygnus/git/rapi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin
</span></span></code></pre></div><p>Use the BCM2709 config, and in MENU CONFIG change the SD card and MMC drivers into kernel modules. Finally build <code>zImage</code>, modules, and device trees, then update the files on the SD card.
<code>kernel.img</code> is used by RPi 1B, 1A, A+, B+, 2B (first version) Z, Z (with camera), ZW, CM1
<code>kernel7.img</code> is used by the RPi2B2, RPi3B, CM3 and CM3L.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">KERNEL</span><span class="o">=</span>kernel7
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- bcm2709_defconfig
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- menuconfig
</span></span><span class="line"><span class="cl">make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- -j16 zImage modules dtbs
</span></span><span class="line"><span class="cl">sudo make <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf- <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>/run/media/cygnus/rootfs modules_install
</span></span></code></pre></div><p>Update kernel:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo cp /run/media/cygnus/boot/<span class="nv">$KERNEL</span>.img /run/media/cygnus/boot/<span class="nv">$KERNEL</span>-backup.img
</span></span><span class="line"><span class="cl">sudo cp arch/arm/boot/zImage /run/media/cygnus/boot/<span class="nv">$KERNEL</span>.img
</span></span></code></pre></div><p>Update device trees:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo cp arch/arm/boot/dts/*.dtb /run/media/cygnus/boot/
</span></span><span class="line"><span class="cl">sudo cp arch/arm/boot/dts/overlays/*.dtb* /run/media/cygnus/boot/overlays/
</span></span></code></pre></div><p>Add the following to the boot config:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">dtoverlay</span><span class="o">=</span>sdio,poll_once<span class="o">=</span>off
</span></span></code></pre></div><p>Wiring:</p>
<table>
  <thead>
      <tr>
          <th>Name</th>
          <th>SD Card</th>
          <th>Raspberry Pi Pin Num</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>VCC</td>
          <td>4</td>
          <td>17</td>
      </tr>
      <tr>
          <td>GND</td>
          <td>6</td>
          <td>20</td>
      </tr>
      <tr>
          <td>CLK/SCLK</td>
          <td>5</td>
          <td>15</td>
      </tr>
      <tr>
          <td>CMD/MOSI</td>
          <td>2</td>
          <td>16</td>
      </tr>
      <tr>
          <td>DAT0/MISO</td>
          <td>7</td>
          <td>18</td>
      </tr>
      <tr>
          <td>DAT1</td>
          <td>8</td>
          <td>22</td>
      </tr>
      <tr>
          <td>DAT2</td>
          <td>9</td>
          <td>37</td>
      </tr>
      <tr>
          <td>DAT3/CS</td>
          <td>1</td>
          <td>13</td>
      </tr>
  </tbody>
</table>
<h2 id="reference">Reference</h2>
<p><a href="https://www.sdcard.org/downloads/pls/index.html"target="_blank" rel="noopener noreferrer">SD Simplified Specifications</a></p>
<p><a href="https://en.wikipedia.org/wiki/Secure_Digital"target="_blank" rel="noopener noreferrer">Wiki - Secure_Digital</a></p>
<p><a href="https://www.sdcard.org/developers/overview/index.html"target="_blank" rel="noopener noreferrer">SD Standard Overview</a></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/sd-card/>SD card</a><a class="tag" href=/en/tags/sd-specification/>SD specification</a><a class="tag" href=/en/tags/sdio/>SDIO</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/tinyscheme-file-io/"><span class="iconfont icon-article"></span>TinyScheme File I/O</a></p><p><a class="link" href="/en/posts/huawei-e5885l-4g-router-tinkering-notes/"><span class="iconfont icon-article"></span>Huawei E5885L 4G Router Tinkering Notes</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>