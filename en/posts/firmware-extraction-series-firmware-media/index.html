<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Firmware
Firmware, also called firmware image in some contexts (and sometimes referred to as ‚ÄúROM‚Äù in mobile communities), resides in non-volatile memory (Non-Volatile Memory, NVM) and can be read and written. In embedded systems, the most common NVM types are ROM (read-only memory) and Flash memory. ROM includes Mask ROM, PROM, EPROM, and EEPROM. Today, the ‚Äúmainstream ROM‚Äù is typically EEPROM, often integrated inside the MCU; meanwhile, the more common external storage is Flash memory."><title>Firmware Extraction Series: Firmware&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series: Firmware" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-firmware-media/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series: Firmware</h1><p class="article date">Saturday, December 28, 2019<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-firmware-media/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="firmware">Firmware</h2>
<p>Firmware, also called <em>firmware image</em> in some contexts (and sometimes referred to as ‚ÄúROM‚Äù in mobile communities), resides in <strong>non-volatile memory</strong> (Non-Volatile Memory, NVM) and can be read and written. In embedded systems, the most common NVM types are <strong>ROM</strong> (read-only memory) and <strong>Flash memory</strong>. ROM includes Mask ROM, PROM, EPROM, and EEPROM. Today, the ‚Äúmainstream ROM‚Äù is typically EEPROM, often integrated inside the MCU; meanwhile, the more common external storage is Flash memory.</p>
<p>In embedded devices, besides plain NAND or NOR flash chips, you may also encounter <strong>eMMC</strong>. For expandable storage, devices may use SD cards, CF cards, HDDs, etc. These are essentially a <em>controller + storage</em> design: the controller talks to the host, and as long as you can access the controller, you can read/write the underlying storage. For devices like eMMC/SD/CF/HDD, the controller exposes a standard external interface, so you can read them with a card reader or a programming socket. For flash chips managed directly by the SoC, there is no generic external interface‚Äîbut the SoC controls them via drivers. As long as you can access memory-mapped peripherals (their address space), you can interact with them. That‚Äôs why techniques like <strong>reading firmware via JTAG</strong>, <strong>IAP</strong>, or <strong>U-Boot</strong> exist; and in theory, even if the main controller is dead, you may still be able to recover firmware from the storage.</p>
<p>As long as an embedded device stores an operating system on such media, I call those original files ‚Äúfirmware‚Äù. In embedded security research, firmware extraction is always the first step‚Äîand often the most critical one‚Äîbecause it determines whether the research can continue. So I decided to organize and share the firmware-extraction knowledge I‚Äôve accumulated over the years.</p>
<h2 id="eeprom-vs-nor-vs-nand-flash">EEPROM vs NOR vs NAND Flash</h2>
<p>EEPROM products typically have a much higher endurance (erase/write cycles) than Flash products. Together with smaller package sizes and lower write/erase currents, EEPROM often becomes the preferred storage technology in automotive applications.</p>
<p>For higher-performance devices, Flash is commonly used. Comparing NAND and NOR: <strong>NOR supports XIP</strong>, and it has fast read performance, but write and erase are slow. <strong>NAND</strong> offers much larger capacity, higher throughput, and lower cost, but generally has lower reliability.
NAND is accessed in <strong>blocks</strong>, while NOR flash can be accessed <strong>randomly</strong>.</p>
<p>To communicate with firmware media and modify its data, you need the corresponding protocols. For EEPROM, common protocols are <strong>I2C</strong> and <strong>SPI</strong> (SPI has multiple modes). NAND flash uses the <strong>Raw NAND</strong> protocol, and most modern devices follow the <strong>ONFI</strong> standard. NOR flash commonly uses SPI; SPI flash often follows <strong>JEDEC SFDP (JESD216)</strong>, while parallel NOR supports <strong>JEDEC CFI (JESD68)</strong>.</p>
<p>JEDEC stands for <em>Joint Electron Device Engineering Council</em>. JEDEC defines standards that help software read the Flash manufacturer ID and device ID to determine Flash size and algorithms.</p>
<p>Note: not all chips strictly follow these standards.</p>
<h2 id="nor-package">NOR Package</h2>
<p>NOR flash comes in parallel and serial variants. Serial NOR is commonly packaged as SOP and uses SPI. Parallel NOR has a few BGA options, but is typically TSOP packaged, e.g. TSOP-56, TFBGA-56, LFBGA-64.</p>
<h2 id="nor-flash-pin-assignment">NOR Flash Pin Assignment</h2>
<p>NOR flash supports random access, so its erase granularity can be as small as a byte. This section refers to <strong>parallel signal pins</strong>‚ÄîNOR pinouts are very similar to SRAM. If you need to wire it manually (flying leads), it becomes especially painful.</p>
<table>
  <thead>
      <tr>
          <th>Symbol</th>
          <th>Pin Name</th>
          <th>Function</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>A[MAX:0]</td>
          <td>Address</td>
          <td>Address bits for read/write operations</td>
      </tr>
      <tr>
          <td>DQ[7:0]</td>
          <td>Data Inputs/Outputs</td>
          <td>Used for command/data input and output</td>
      </tr>
      <tr>
          <td>DQ[14:8]</td>
          <td>Data Inputs/Outputs</td>
          <td>Used for command/data input and output</td>
      </tr>
      <tr>
          <td>DQ15/A-1</td>
          <td>Data Inputs/Outputs</td>
          <td>Data or address input</td>
      </tr>
      <tr>
          <td>BYTE#</td>
          <td>Byte/word organization select</td>
          <td>Select 8-bit or 16-bit mode</td>
      </tr>
      <tr>
          <td>CE#</td>
          <td>Chip Enable</td>
          <td>Chip enable</td>
      </tr>
      <tr>
          <td>RE#</td>
          <td>Read Enable</td>
          <td>Read enable; data is valid on the falling edge of RE# pulse</td>
      </tr>
      <tr>
          <td>OE#</td>
          <td>Output Enable</td>
          <td>Output enable; when OE# is LOW, data is driven during read cycles; when OE# is HIGH, outputs are high-impedance</td>
      </tr>
      <tr>
          <td>WE#</td>
          <td>Write Enable</td>
          <td>Write enable</td>
      </tr>
      <tr>
          <td>WP#</td>
          <td>Write Protect</td>
          <td>Protects against unintended program/erase; when WP# is LOW, other operations are blocked</td>
      </tr>
      <tr>
          <td>RST#</td>
          <td>Reset</td>
          <td></td>
      </tr>
      <tr>
          <td>RY/BY#</td>
          <td>Read / Busy Output</td>
          <td>LOW during program/erase/random write; returns HIGH when done. When the chip is not selected or output is disabled, this pin is open-drain and high-impedance; a pull-up resistor is required</td>
      </tr>
      <tr>
          <td>Vcc</td>
          <td>Power</td>
          <td>3.3V or 1.8V supply</td>
      </tr>
      <tr>
          <td>Vss</td>
          <td>Ground</td>
          <td>Ground</td>
      </tr>
      <tr>
          <td>NC</td>
          <td>No Connection</td>
          <td>No connection</td>
      </tr>
  </tbody>
</table>
<p>TSOP-56</p>
<p><img loading="lazy"  src="./TSOP56.png"
        alt="TSOP-56"/></p>
<h2 id="nand-flash">NAND Flash</h2>
<p>NAND flash is a type of non-volatile memory. In embedded devices, <strong>SLC</strong> (1-bit per cell) is commonly used. It uses a floating-gate structure that traps electrons inside an insulated gate so data remains after power-off. Flash memory does <strong>not</strong> support overwriting in place‚Äîprogram operations can only write into empty (erased) cells.</p>
<p>One way to erase cells is to apply a positive voltage to the source and leverage tunneling effects between the first floating gate and the drain, pulling the negative charge out of the floating gate toward the source. Because erasing uses a positive voltage at the source and sources are tied together, erasing cannot be done per byte; it must be done per chip or per block.</p>
<h2 id="nand-package">NAND Package</h2>
<p>The ONFI standard defines several common NAND packages. NAND flash is typically TSOP or BGA, both using SMT. The figures below show pin definitions for different packages.</p>
<p>TSOP-48</p>
<p><img loading="lazy"  src="./TSOP48.png"
        alt="TSOP-48"/></p>
<p>BGA-63</p>
<p><img loading="lazy"  src="./BGA63.png"
        alt="BGA-63"/></p>
<h2 id="nand-flash-pin-assignment">NAND Flash Pin Assignment</h2>
<p>NAND flash uses parallel I/O, typically 8-bit (x8). Pins with an overline (represented with ‚Äú#‚Äù here) are <strong>active-low</strong>, and by default should be pulled up.</p>
<table>
  <thead>
      <tr>
          <th>Symbol</th>
          <th>Pin Name</th>
          <th>Function</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>I/O x</td>
          <td>Data Inputs/Outputs</td>
          <td>Used for command/address/data I/O. When the chip is not selected or output is disabled, I/O pins are high-impedance</td>
      </tr>
      <tr>
          <td>CLE</td>
          <td>Command Latch Enable</td>
          <td>When CLE is HIGH, commands are latched into the command register on the rising edge of WE#</td>
      </tr>
      <tr>
          <td>ALE</td>
          <td>Address Latch Enable</td>
          <td>When ALE is HIGH, addresses are latched into the address register on the rising edge of WE#</td>
      </tr>
      <tr>
          <td>CE#</td>
          <td>Chip Enable</td>
          <td>Chip enable; without CE asserted, the device stays in standby and ignores control signals</td>
      </tr>
      <tr>
          <td>RE#</td>
          <td>Read Enable</td>
          <td>Read enable; data is valid on the falling edge of RE# pulse</td>
      </tr>
      <tr>
          <td>WE#</td>
          <td>Write Enable</td>
          <td>Write enable; writes data/address/command into NAND on the rising edge of WE#</td>
      </tr>
      <tr>
          <td>WP#</td>
          <td>Write Protect</td>
          <td>Protects against unintended program/erase; when WP# is LOW, other operations are blocked</td>
      </tr>
      <tr>
          <td>R/B#</td>
          <td>Read / Busy Output</td>
          <td>LOW during program/erase/random write; returns HIGH when done. When the chip is not selected or output is disabled, this pin is open-drain and high-impedance; a pull-up resistor is required</td>
      </tr>
      <tr>
          <td>Vcc</td>
          <td>Power</td>
          <td>3.3V or 1.8V supply</td>
      </tr>
      <tr>
          <td>Vss</td>
          <td>Ground</td>
          <td>Ground</td>
      </tr>
      <tr>
          <td>NC</td>
          <td>No Connection</td>
          <td>No connection</td>
      </tr>
  </tbody>
</table>
<p><img loading="lazy"  src="./block_diagram.png"
        alt="block_diagram"/></p>
<h2 id="array-organization">Array Organization</h2>
<p>Below is an example of the array organization of an 8-bit NAND from ESMT: each page contains 2048 bytes of data + 64 bytes of spare/cache, each block contains 64 pages, and the device has 1024 blocks. Including the spare area, that is 1056 Mbit total‚Äîi.e. 128 MB capacity + 4 MB spare.</p>
<p><img loading="lazy"  src="./array_organization.png"
        alt="array_oragnization"/></p>
<h2 id="tools-for-reading-firmware">Tools for Reading Firmware</h2>
<p>This section focuses on non-expandable storage. Based on the extraction method, firmware reading can be grouped into:</p>
<ul>
<li><strong>Chip-off (offline)</strong>: remove the target chip and read it with a programmer + socket. This has higher cost, and the programmer (or its controller) may not perfectly match the target chip, so manual firmware repair is often required.</li>
<li><strong>In-circuit / online</strong>: attach external tools to the device and read via SoC-specific debug interfaces or storage-chip standard interfaces. Common prep includes a USB harness, or debuggers like J-Link, USBDM, etc. (some less common chips require special tools). This is typically an IAP-style extraction.</li>
<li><strong>Internal backup</strong>: obtain sufficient privileges on the device and back up data from block devices, or read data via I2C/SPI driver interfaces.</li>
</ul>
<p>After understanding chip standards and communication protocols, you don‚Äôt necessarily need a dedicated programmer for less common storage chips. With an STM32, AVR, or even a Raspberry Pi, you can often complete firmware extraction.</p>
<h2 id="how-embedded-devices-use-flash">How Embedded Devices Use Flash</h2>
<p>One way NOR flash resembles regular memory is that both support random access. This also enables <strong>XIP (eXecute In Place)</strong>, so code can run directly from NOR like a ROM. That makes NOR an excellent medium for code that must execute at power-on, such as BIOS/boot code.</p>
<p>Unlike NOR, NAND does not support XIP, so it cannot store the very first-stage bootloader directly.</p>
<p>Early phones and similar devices used both NOR and NAND. NOR was small but supported XIP, so it initialized the system and provided the NAND driver‚Äîfunctionally similar to a bootloader. NAND stored data and the OS image. Samsung later proposed the ‚ÄúNOR-less‚Äù concept: by hardcoding the NAND driver in the CPU‚Äôs on-die ROM and copying a small initial portion of NAND into low memory as a bootloader, expensive NOR flash could be eliminated‚Äîreducing board cost and complexity. Over time, NOR gradually disappeared from phones.</p>
<p>Compared with NOR, NAND is more prone to bit flips, so <strong>error detection/correction (EDC/ECC)</strong> is required. NAND also develops bad blocks over time. Typically, a software layer is needed to handle bad-block management, wear leveling, ECC, and garbage collection. This layer is called <strong>FTL (Flash Translation Layer)</strong>. Depending on where the FTL resides, Flash memory can be categorized into <strong>Raw Flash</strong> and <strong>Managed Flash</strong>.</p>
<p>In the early days, Raw Flash was common and the FTL lived entirely in the driver. Later, for SD/eMMC and similar media, the controller implements it in hardware.</p>
<p>Therefore, when reading raw NAND, you must also consider bad-block management, wear leveling, ECC, etc.</p>
<p>ECC is usually the hardest part: reading NAND with a programmer often yields errors and needs correction. Many NAND devices use hardware ECC, and the algorithm is hardware-dependent. For SLC parts, common codes include Hamming and BCH. There isn‚Äôt a single ‚Äústandard‚Äù open-source implementation for every vendor‚Äôs exact parameters, so you often need special channels to obtain the correct ECC algorithm/parameters.</p>
<p>Based on how the storage chip is used in the system, you can infer whether it stores a bootloader, the OS, or temporary data. And based on the supported standards, you can decide how to read its contents.
More advanced firmware-extraction topics will be shared in follow-up posts.</p>
<h2 id="reference">Reference</h2>
<p><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf"target="_blank" rel="noopener noreferrer">NAND vs. NOR Flash Memory Technology Overview</a></p>
<p><a href="https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/"target="_blank" rel="noopener noreferrer">Understanding Flash: Blocks, Pages and Program / Erases</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26745577"target="_blank" rel="noopener noreferrer">UEFI Blog ÊùÇË∞àÈó™Â≠ò‰∫åÔºöNORÂíåNAND Flash</a></p>
<p><a href="https://www.design-reuse.com/articles/24503/nand-flash-memory-embedded-systems.html"target="_blank" rel="noopener noreferrer">NAND Flash memory in embedded systems</a></p>
<p><a href="https://www.jedec.org/"target="_blank" rel="noopener noreferrer">JEDEC</a></p>
<p><a href="http://www.onfi.org/"target="_blank" rel="noopener noreferrer">ONFI</a></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/nand/>NAND</a><a class="tag" href=/en/tags/firmware-extraction/>Firmware Extraction</a><a class="tag" href=/en/tags/embedded-security/>Embedded Security</a><a class="tag" href=/en/tags/iot/>IoT</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/bypass-jvmti-encryption-protection/"><span class="iconfont icon-article"></span>Bypassing JVMTI-Based Encryption Protection</a></p><p><a class="link" href="/en/posts/firmware-extraction-series-ubi-extract-and-repack/"><span class="iconfont icon-article"></span>Firmware Extraction Series: UBI Filesystem Extraction and Repacking</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>