<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="What is Firmware?
Firmware, sometimes referred to as a firmware image (or simply &ldquo;ROM&rdquo; in mobile communities), resides in Non-Volatile Memory (NVM) and can be both read and written. In embedded systems, the most common NVM types are ROM (Read-Only Memory) and Flash memory. While strictly speaking, &ldquo;ROM&rdquo; includes Mask ROM, PROM, EPROM, and EEPROM, modern &ldquo;mainstream ROM&rdquo; usually refers to EEPROM integrated within an MCU. Flash memory typically serves as the primary external storage."><title>Firmware Extraction Series: Firmware Media&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series: Firmware Media" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-firmware-media/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series: Firmware Media</h1><p class="article date">Saturday, December 28, 2019<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-firmware-media/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="what-is-firmware">What is Firmware?</h2>
<p>Firmware, sometimes referred to as a <em>firmware image</em> (or simply &ldquo;ROM&rdquo; in mobile communities), resides in <strong>Non-Volatile Memory (NVM)</strong> and can be both read and written. In embedded systems, the most common NVM types are <strong>ROM</strong> (Read-Only Memory) and <strong>Flash memory</strong>. While strictly speaking, &ldquo;ROM&rdquo; includes Mask ROM, PROM, EPROM, and EEPROM, modern &ldquo;mainstream ROM&rdquo; usually refers to EEPROM integrated within an MCU. Flash memory typically serves as the primary external storage.</p>
<p>In embedded devices, beyond standard NAND or NOR flash chips, you may also encounter <strong>eMMC</strong>. For expandable storage, devices might use SD cards, CF cards, USB drives, or HDDs. These storage solutions generally follow a <em>controller + storage</em> architecture: a controller bridges the host and the storage medium. As long as you can interact with the controller, you can read or write to the underlying storage.</p>
<p>Devices like eMMC, SD cards, and HDDs expose standard external interfaces, allowing them to be read using standard card readers or programming sockets. In contrast, raw flash chips are managed directly by the SoC (System on Chip) via specific drivers; they lack a generic external interface. However, because these chips are memory-mapped peripherals, you can interact with them if you can access their address space. This is the principle behind techniques like <strong>reading firmware via JTAG</strong>, <strong>IAP (In-Application Programming)</strong>, or <strong>bootloaders (like U-Boot)</strong>. Theoretically, even if the device&rsquo;s main controller is non-functional, the firmware can still be recovered directly from the storage chip.</p>
<p>For the purpose of this series, I define &ldquo;firmware&rdquo; as the original files containing the operating system and data stored on these media. In embedded security research, firmware extraction is almost always the first‚Äîand most critical‚Äîstep. Without the firmware, further research often hits a dead end. This series aims to systematically share the knowledge and techniques I&rsquo;ve accumulated over years of performing firmware extraction.</p>
<h2 id="eeprom-vs-nor-vs-nand-flash">EEPROM vs. NOR vs. NAND Flash</h2>
<p><strong>EEPROM</strong> typically offers much higher endurance (erase/write cycles) than Flash memory. Combined with small package sizes and low write/erase power consumption, EEPROM is often the preferred choice for storing configuration data, particularly in automotive applications.</p>
<p>For high-performance storage, <strong>Flash memory</strong> is the standard. There are two main types:</p>
<ul>
<li><strong>NOR Flash:</strong> Supports <strong>XIP (eXecute In Place)</strong> and offers fast read speeds, but provides slower write and erase operations. It supports <strong>random access</strong>, making it ideal for code execution.</li>
<li><strong>NAND Flash:</strong> Accessed in <strong>blocks</strong> rather than randomly. It offers significantly higher capacity, higher throughput, and lower cost per bit, but generally has lower reliability and requires complex management.</li>
</ul>
<p>To communicate with these media, you must speak their protocols:</p>
<ul>
<li><strong>EEPROM:</strong> Typically uses <strong>I2C</strong> or <strong>SPI</strong> (Serial Peripheral Interface).</li>
<li><strong>NOR Flash:</strong> Serial NOR usually uses <strong>SPI</strong>; Parallel NOR uses a parallel bus. Protocol standards include <strong>JEDEC SFDP (JESD216)</strong> for SPI and <strong>JEDEC CFI (JESD68)</strong> for parallel NOR.</li>
<li><strong>NAND Flash:</strong> Uses the <strong>Raw NAND</strong> protocol, with most modern devices adhering to the <strong>ONFI</strong> (Open NAND Flash Interface) standard.</li>
</ul>
<p><em>Note: JEDEC (Joint Electron Device Engineering Council) defines standards that allow software to query a Flash chip&rsquo;s manufacturer and device IDs to determine its size and capabilities. However, not all chips strictly adhere to these standards.</em></p>
<h2 id="nor-flash-packages">NOR Flash Packages</h2>
<p>NOR flash is available in parallel and serial variants.</p>
<ul>
<li><strong>Serial NOR:</strong> Commonly packaged as <strong>SOP</strong> (Small Outline Package) and uses SPI.</li>
<li><strong>Parallel NOR:</strong> Typically uses <strong>TSOP</strong> (Thin Small Outline Package) like TSOP-56, or BGA (Ball Grid Array) like TFBGA-56 and LFBGA-64.</li>
</ul>
<h2 id="nor-flash-pin-assignment">NOR Flash Pin Assignment</h2>
<p>Because NOR flash supports random access, it functions similarly to SRAM. Below is the pinout for a parallel NOR flash chip. Manually wiring these (using &ldquo;flying leads&rdquo;) can be tedious due to the high pin count.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Symbol</th>
          <th style="text-align: left">Pin Name</th>
          <th style="text-align: left">Function</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>A[MAX:0]</strong></td>
          <td style="text-align: left">Address</td>
          <td style="text-align: left">Address bits for read/write operations</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>DQ[7:0]</strong></td>
          <td style="text-align: left">Data I/O</td>
          <td style="text-align: left">Inputs/Outputs for commands and data</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>DQ[14:8]</strong></td>
          <td style="text-align: left">Data I/O</td>
          <td style="text-align: left">Inputs/Outputs for commands and data</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>DQ15/A-1</strong></td>
          <td style="text-align: left">Data I/O</td>
          <td style="text-align: left">Data or address input (for x8/x16 mode switching)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>BYTE#</strong></td>
          <td style="text-align: left">Byte/Word Select</td>
          <td style="text-align: left">Selects 8-bit or 16-bit data organization</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>CE#</strong></td>
          <td style="text-align: left">Chip Enable</td>
          <td style="text-align: left">Activates the device</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>RE#</strong></td>
          <td style="text-align: left">Read Enable</td>
          <td style="text-align: left">Data is valid on the falling edge of this pulse</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>OE#</strong></td>
          <td style="text-align: left">Output Enable</td>
          <td style="text-align: left">Drives data onto the bus when LOW; high-impedance when HIGH</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>WE#</strong></td>
          <td style="text-align: left">Write Enable</td>
          <td style="text-align: left">Triggers write operations</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>WP#</strong></td>
          <td style="text-align: left">Write Protect</td>
          <td style="text-align: left">Prevents unintended program/erase operations when LOW</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>RST#</strong></td>
          <td style="text-align: left">Reset</td>
          <td style="text-align: left">Resets the device</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>RY/BY#</strong></td>
          <td style="text-align: left">Read/Busy</td>
          <td style="text-align: left">Output LOW during operations; HIGH when ready. Requires a pull-up resistor (open-drain).</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Vcc</strong></td>
          <td style="text-align: left">Power</td>
          <td style="text-align: left">Supply Voltage (typically 3.3V or 1.8V)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Vss</strong></td>
          <td style="text-align: left">Ground</td>
          <td style="text-align: left">Ground</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>NC</strong></td>
          <td style="text-align: left">No Connection</td>
          <td style="text-align: left">Unconnected pin</td>
      </tr>
  </tbody>
</table>
<p><strong>TSOP-56 Pinout:</strong></p>
<p><img loading="lazy"  src="./TSOP56.png"
        alt="TSOP-56"/></p>
<h2 id="nand-flash">NAND Flash</h2>
<p>NAND flash is a type of non-volatile storage optimized for high density. Embedded devices commonly use <strong>SLC (Single Level Cell)</strong> NAND, which stores 1 bit per cell.</p>
<p>Flash memory uses a <strong>floating-gate</strong> transistor structure. Electrons are trapped in an insulated floating gate to store data. A key characteristic of Flash is that it <strong>cannot support in-place overwrites</strong>. Writing involves capturing electrons, but &ldquo;erasing&rdquo; involves releasing them. To erase, a high voltage is applied to pull electrons from the floating gate. Because the source connections are grouped, <strong>erasure must happen in large blocks</strong>, not individual bytes.</p>
<h2 id="nand-packages">NAND Packages</h2>
<p>The ONFI standard defines several common packages for NAND flash, typically using SMT (Surface Mount Technology).</p>
<p><strong>TSOP-48:</strong></p>
<p><img loading="lazy"  src="./TSOP48.png"
        alt="TSOP-48"/></p>
<p><strong>BGA-63:</strong></p>
<p><img loading="lazy"  src="./BGA63.png"
        alt="BGA-63"/></p>
<h2 id="nand-flash-pin-assignment">NAND Flash Pin Assignment</h2>
<p>NAND flash uses a multiplexed parallel I/O interface, typically 8-bit (x8). Pins marked with <code>#</code> are <strong>active-low</strong> and usually require pull-up resistors.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Symbol</th>
          <th style="text-align: left">Pin Name</th>
          <th style="text-align: left">Function</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>I/O x</strong></td>
          <td style="text-align: left">Data I/O</td>
          <td style="text-align: left">Used for command, address, and data input/output. High-impedance when disabled.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>CLE</strong></td>
          <td style="text-align: left">Command Latch Enable</td>
          <td style="text-align: left">When HIGH, commands are latched on the rising edge of WE#.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>ALE</strong></td>
          <td style="text-align: left">Address Latch Enable</td>
          <td style="text-align: left">When HIGH, addresses are latched on the rising edge of WE#.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>CE#</strong></td>
          <td style="text-align: left">Chip Enable</td>
          <td style="text-align: left">Activates the device. When marked high, the device enters standby.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>RE#</strong></td>
          <td style="text-align: left">Read Enable</td>
          <td style="text-align: left">Data is driven onto the bus on the falling edge of this pulse.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>WE#</strong></td>
          <td style="text-align: left">Write Enable</td>
          <td style="text-align: left">Latches data/address/commands on the rising edge.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>WP#</strong></td>
          <td style="text-align: left">Write Protect</td>
          <td style="text-align: left">Hardware write protection.</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>R/B#</strong></td>
          <td style="text-align: left">Read/Busy</td>
          <td style="text-align: left">Indicates device status. LOW = Busy; HIGH = Ready. Open-drain output (requires pull-up).</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Vcc</strong></td>
          <td style="text-align: left">Power</td>
          <td style="text-align: left">Supply Voltage (3.3V / 1.8V)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Vss</strong></td>
          <td style="text-align: left">Ground</td>
          <td style="text-align: left">Ground</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>NC</strong></td>
          <td style="text-align: left">No Connection</td>
          <td style="text-align: left">Unconnected</td>
      </tr>
  </tbody>
</table>
<p><img loading="lazy"  src="./block_diagram.png"
        alt="block_diagram"/></p>
<h2 id="array-organization">Array Organization</h2>
<p>NAND is organized hierarchically. Below is the organization of an 8-bit NAND chip from ESMT:</p>
<ul>
<li><strong>Page:</strong> 2048 bytes (Data) + 64 bytes (Spare/OOB)</li>
<li><strong>Block:</strong> 64 Pages</li>
<li><strong>Device:</strong> 1024 Blocks</li>
<li><strong>Total Capacity:</strong> 1056 Mbits (128 MB Data + 4 MB Spare)</li>
</ul>
<p><img loading="lazy"  src="./array_organization.png"
        alt="array_oragnization"/></p>
<h2 id="tools-for-reading-firmware">Tools for Reading Firmware</h2>
<p>For non-expandable storage (soldered chips), reading methods fall into three categories:</p>
<ol>
<li><strong>Chip-off (Offline):</strong> Desolder the chip and read it using a dedicated programmer and socket.
<ul>
<li><em>Pros:</em> Direct access, works if the device is dead.</li>
<li><em>Cons:</em> Higher cost (hardware), potential for damage, requires handling ECC/bad blocks manually.</li>
</ul>
</li>
<li><strong>In-System / In-Circuit (Online):</strong> Connect external tools to the PCB to read the chip without desoldering.
<ul>
<li><em>Methods:</em> SoC debug interfaces (JTAG/SWD) or clamping directly to the storage chip pins (e.g., using a test clip).</li>
<li><em>Tools:</em> J-Link, USBDM, Bus Pirate, or custom harnesses.</li>
</ul>
</li>
<li><strong>Internal Backup (Software):</strong> Gain shell access (e.g., via UART or partial exploit) and use system tools (<code>dd</code>, <code>cat</code>, <code>nanddump</code>) to dump the firmware partitions.</li>
</ol>
<p><em>Tip: You don&rsquo;t always need expensive programmers. For common protocols, a microcontroller (STM32, AVR) or a Raspberry Pi can often be repurposed as a dumper.</em></p>
<h2 id="architecture-how-embedded-devices-use-flash">Architecture: How Embedded Devices Use Flash</h2>
<p><strong>NOR Flash</strong> is similar to standard RAM: it supports random access. This enables <strong>XIP (eXecute In Place)</strong>, allowing the CPU to fetch and execute instructions directly from the flash memory. This makes NOR ideal for storing the <strong>bootloader</strong> or BIOS, which must run immediately upon power-up.</p>
<p><strong>NAND Flash</strong>, by contrast, does <strong>not</strong> support XIP. The CPU cannot execute code directly from NAND. Therefore, the very first stage of boot code cannot reside solely on NAND.</p>
<p><strong>Historical Context (The &ldquo;NOR-less&rdquo; Shift):</strong>
Early devices (like feature phones) used both NOR and NAND: NOR for the bootloader/kernel (XIP) and NAND for the filesystem (storage). Samsung later popularized the &ldquo;NOR-less&rdquo; concept. By embedding a small ROM inside the SoC capable of loading a bootloader from the first page of NAND into internal RAM, they eliminated the need for expensive NOR chips. This reduced cost and complexity, making NOR rare in modern high-volume consumer electronics like smartphones.</p>
<p><strong>Managed Flash &amp; FTL:</strong>
NAND is susceptible to <strong>bit flips</strong> and <strong>bad blocks</strong>. It requires a complex software management layer called the <strong>FTL (Flash Translation Layer)</strong> to handle:</p>
<ul>
<li>Error Correction Codes (ECC)</li>
<li>Bad Block Management</li>
<li>Wear Leveling</li>
<li>Garbage Collection</li>
</ul>
<p>Depending on where this FTL resides, flash is categorized as:</p>
<ul>
<li><strong>Raw Flash:</strong> The FTL is implemented in the OS driver (software).</li>
<li><strong>Managed Flash (eMMC, SD, UFS):</strong> The FTL is implemented in a hardware controller inside the storage package.</li>
</ul>
<p><strong>Implications for Extraction:</strong>
When reading <strong>Raw NAND</strong>, you get the raw data including bit errors and OOB (Out-Of-Band) metadata. You must manually handle ECC algorithms (e.g., Hamming, BCH) and descrambling to reconstruct a valid binary. Since these algorithms are often vendor-specific and not standard, this is the most challenging part of raw firmware extraction.</p>
<p>Advanced topics on reconstructing firmware from raw dumps will be covered in future posts.</p>
<h2 id="references">References</h2>
<p><a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/Toshiba%20NAND_vs_NOR_Flash_Memory_Technology_Overviewt.pdf"target="_blank" rel="noopener noreferrer">NAND vs. NOR Flash Memory Technology Overview</a></p>
<p><a href="https://flashdba.com/2014/06/20/understanding-flash-blocks-pages-and-program-erases/"target="_blank" rel="noopener noreferrer">Understanding Flash: Blocks, Pages and Program / Erases</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/26745577"target="_blank" rel="noopener noreferrer">UEFI Blog ÊùÇË∞àÈó™Â≠ò‰∫åÔºöNORÂíåNAND Flash</a></p>
<p><a href="https://www.design-reuse.com/articles/24503/nand-flash-memory-embedded-systems.html"target="_blank" rel="noopener noreferrer">NAND Flash memory in embedded systems</a></p>
<p><a href="https://www.jedec.org/"target="_blank" rel="noopener noreferrer">JEDEC</a></p>
<p><a href="http://www.onfi.org/"target="_blank" rel="noopener noreferrer">ONFI</a></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/nand/>NAND</a><a class="tag" href=/en/tags/firmware-extraction/>Firmware Extraction</a><a class="tag" href=/en/tags/embedded-security/>Embedded Security</a><a class="tag" href=/en/tags/iot/>IoT</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/bypass-jvmti-encryption-protection/"><span class="iconfont icon-article"></span>Bypassing JVMTI-Based Encryption Protection</a></p><p><a class="link" href="/en/posts/firmware-extraction-series-ubi-extract-and-repack/"><span class="iconfont icon-article"></span>Firmware Extraction Series: UBI Filesystem Extraction and Repacking</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>