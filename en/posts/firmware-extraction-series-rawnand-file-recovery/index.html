<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Preface
This post documents the process of restoring the NAND Flash filesystem from an in-vehicle head unit."><title>Firmware Extraction Series - Raw NAND File Recovery&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series - Raw NAND File Recovery" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-rawnand-file-recovery/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series - Raw NAND File Recovery</h1><p class="article date">Sunday, March 10, 2019<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-rawnand-file-recovery/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="preface">Preface</h2>
<p>This post documents the process of restoring the NAND Flash filesystem from an in-vehicle head unit.</p>
<h2 id="recovery-process">Recovery process</h2>
<p>The head unit is equipped with an MXIC B162711 NAND Flash storage chip and a Qualcomm CPU. Raw NAND Flash is typically not controlled directly by the host processor unless the vendor, such as Qualcomm, is highly confident in their controller/SoC implementation.
During hardware analysis, I observed no anti-tamper measures on the chip, so I proceeded to desolder it using a hot-air rework station.</p>
<p><img loading="lazy"  src="./tearoff.png"
        alt="tearoff"/></p>
<p>The chip details are shown below; it is a 512MB SLC NAND.</p>
<p><img loading="lazy"  src="./features.png"
        alt="features"/></p>
<p>The chip utilizes a BGA63 package with the following pinout:</p>
<p><img loading="lazy"  src="./bga63.png"
        alt="bga63"/></p>
<p>The extraction process was performed using a Proman programmer:</p>
<p><img loading="lazy"  src="./socket.png"
        alt="socket"/></p>
<p><img loading="lazy"  src="./reading.png"
        alt="reading"/></p>
<p>I read the chip multiple times and compared the resulting dumps. To mitigate the impact of bit flips and ensure data integrity, I applied a majority-voting algorithm, retaining the most frequent byte values.</p>
<p><img loading="lazy"  src="./bytes_diff.png"
        alt="bytes_diff"/></p>
<p>The head unit is powered by a Qualcomm CSR3703 SoC.</p>
<p><img loading="lazy"  src="./CSR3703.png"
        alt="CSR3703"/></p>
<p>The datasheet for this chip is not publicly available. Despite exhaustive searches, I was unable to obtain it, as the documentation is kept strictly confidential.</p>
<p>Even after a manual teardown, the specific chip variant could not be identified solely from the BGA layout.</p>
<p><img loading="lazy"  src="./CSR3703pin.png"
        alt="CSR3703pin"/></p>
<p>Through black-box analysis, I confirmed that the SoC‚Äôs memory mapping table resides within the NAND controller. Consequently, the logical block order cannot be directly determined from the raw firmware dump.</p>
<p><img loading="lazy"  src="./soc_block_diagram.png"
        alt="soc_block_diagram"/></p>
<p>As a result, I had to analyze the extracted firmware without knowledge of the mapping. By examining the raw binary data from the NAND dump, I was able to carve out some low-level system components, including U-Boot.</p>
<p><img loading="lazy"  src="./binwalk.png"
        alt="binwalk"/></p>
<p>While U-Boot can be reverse-engineered, the critical information lies within the system partition.</p>
<p>CSR Visor analysis (128KB):</p>
<p><img loading="lazy"  src="./dts1.png"
        alt="dts1"/></p>
<p>The Device Tree indicates that the console is <code>ttySiRF1</code> running at 115200 baud.</p>
<p><img loading="lazy"  src="./dts2.png"
        alt="dts2"/></p>
<p>NAND controller configuration details:</p>
<p><img loading="lazy"  src="./dts3.png"
        alt="dts3"/></p>
<p>Since the erase block distribution in the first head unit&rsquo;s NAND dump appeared overly random, I decided to desolder and read the NAND Flash from a second, identical head unit.</p>
<p><img loading="lazy"  src="./reball1.png"
        alt="reball1"/>
<img loading="lazy"  src="./reball2.png"
        alt="reball2"/></p>
<p>To restore the head unit to working condition, I reballed the chip and reattached it using an optical rework station for precise alignment.</p>
<p><img loading="lazy"  src="./reball3.png"
        alt="reball3"/></p>
<p>After further research, I suspected the Wear Leveling (WL) mechanism might be using a hybrid mode. I reviewed publicly available FTL (Flash Translation Layer) implementations but could not find matching mapping logic. I hypothesized that the FTL table might be stored in the NAND controller&rsquo;s ROM.</p>
<p><img loading="lazy"  src="./compact_flash_system.png"
        alt="compact_flash_system"/></p>
<p>By analyzing U-Boot, I determined it utilizes a proprietary <code>NANDDisk</code> driver which uses <code>ioctl</code> for NAND read/write operations. The mapping algorithm, however, was not implemented within the driver itself.</p>
<p><img loading="lazy"  src="./nand_driver.png"
        alt="nand_driver"/></p>
<p>Consequently, I could only recover fragmented files rather than a complete filesystem. To verify if the mapping table was stored inside the SoC, I performed a controlled experiment using two identical head units. I swapped their NAND chips (reballing and resoldering each time). Neither head unit would boot with the other&rsquo;s NAND Flash. However, when the original chips were returned to their respective units, both booted successfully. This confirmed that the mapping logic or table is tied to the specific SoC.</p>
<p><img loading="lazy"  src="./reball_again.png"
        alt="reball_again"/></p>
<p>After multiple comparisons, I managed to extract a RAMdisk with over 50% integrity, allowing me to successfully read the first half of the data.</p>
<p><img loading="lazy"  src="./binalk_again.png"
        alt="binalk_again"/></p>
<p><img loading="lazy"  src="./hex_workshop.png"
        alt="hex_workshop"/></p>
<p>I confirmed the use of a Linux EXT filesystem. The MBR information indicated three partitions:</p>
<p><img loading="lazy"  src="./010editor.png"
        alt="010editor"/></p>
<p>Partition 1: 30MB</p>
<p>Partition 2: 400MB</p>
<p>Partition 3: 61.75MB</p>
<p>The remaining files were primarily resources and fragmented ELF binaries. Due to the fragmentation, proper reverse engineering of the ELF files was not possible.</p>
<p><img loading="lazy"  src="./files_1.png"
        alt="files_1"/></p>
<p>I attempted to manually deduce the erase-block ordering logic by splitting and analyzing each block. However, inconsistencies between the initial and subsequent OOB areas misled my initial analysis. I only managed to recover the page order, which allowed reconstruction of the smaller <code>zImage</code> and <code>ramdisk</code>, but the overall mapping logic remained elusive.</p>
<p><img loading="lazy"  src="./files_2.png"
        alt="files_2"/></p>
<p>I also failed to locate a map table within the NAND dump. Quick filesystem recovery was impossible; I needed to analyze the block patterns to derive the underlying mapping logic.</p>
<p>I decided to remove and read the NAND Flash from the second head unit. Unfortunately, the two units were running different system versions, which hindered further comparative analysis.</p>
<p>XXXXX_IHU_LOW_A7_LINUX_18.0F40</p>
<p>XXXXX_IHU_LOW_A7_LINUX_18.0F43</p>
<p>The kernel and ramdisk build timestamps and page layouts were inconsistent, making it impossible to infer the mapping algorithm through comparison.</p>
<p><img loading="lazy"  src="./modification_time.png"
        alt="modification_time"/>
<img loading="lazy"  src="./modification_time2.png"
        alt="modification_time2"/></p>
<p>Suspecting a hybrid mapping scheme, I obtained a firmware image of the same version via a USB HID &ldquo;GetShell&rdquo; exploit. Analyzing this known-good firmware allowed me to derive the mapping algorithm.</p>
<p><img loading="lazy"  src="./struct.png"
        alt="struct"/></p>
<p>Below is the script I used to reconstruct the NAND dump. Looking back, I don&rsquo;t recall the specific details of the logic, but it was effective at the time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python3</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">binascii</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">struct</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Usage: fuckftl.py ftl.bin raw.bin&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bin2hex</span><span class="p">(</span><span class="nb">bin</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">b2a_hex</span><span class="p">(</span><span class="nb">bin</span><span class="p">),</span> <span class="s2">&#34;utf-8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">hex2int</span><span class="p">(</span><span class="nb">hex</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0x&#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_hex_tens_place</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">num</span> <span class="o">/</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="n">num</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0x10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_le_int16</span><span class="p">(</span><span class="n">be</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&#34;&lt;H&#34;</span><span class="p">,</span> <span class="n">be</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">proman_file_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">raw_file_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">nanddisk_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">readable_block_addr</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&#34;sp_.bin&#34;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">sp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">proman_file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">proman_file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">promanbin</span> <span class="o">=</span> <span class="n">proman_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">proman_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">raw_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">raw_file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">promanbin</span><span class="p">),</span> <span class="mh">0x840</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                    <span class="n">pbuffer</span> <span class="o">=</span> <span class="n">promanbin</span><span class="p">[</span><span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="mh">0x840</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="n">page_a</span> <span class="o">=</span> <span class="n">pbuffer</span><span class="p">[:</span><span class="mh">0x400</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="n">page_b</span> <span class="o">=</span> <span class="n">pbuffer</span><span class="p">[</span><span class="mh">0x415</span><span class="p">:</span><span class="mh">0x800</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="n">page_c</span> <span class="o">=</span> <span class="n">pbuffer</span><span class="p">[</span><span class="mh">0x816</span><span class="p">:</span><span class="mh">0x82B</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">sparea_b</span> <span class="o">=</span> <span class="n">pbuffer</span><span class="p">[</span><span class="mh">0x800</span><span class="p">:</span><span class="mh">0x816</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">sparea_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xFF\x42\x00\x00</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sparea_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xFF\x41\xFF\xFF</span><span class="s1">&#39;</span> <span class="ow">and</span> <span class="n">sparea_b</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x00</span><span class="s1">&#39;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                        <span class="n">x_addr</span> <span class="o">=</span> <span class="n">get_le_int16</span><span class="p">(</span><span class="n">sparea_b</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="n">x_addr</span> <span class="ow">in</span> <span class="n">readable_block_addr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="n">cur_wl_version</span> <span class="o">=</span>  <span class="n">get_le_int16</span><span class="p">(</span><span class="n">sparea_b</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="n">readable_block_addr</span><span class="p">[</span><span class="n">x_addr</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cur_wl_version</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                <span class="n">readable_block_addr</span><span class="p">[</span><span class="n">x_addr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mh">0x840</span> <span class="o">*</span> <span class="mh">0x800</span><span class="p">),</span> <span class="n">get_le_int16</span><span class="p">(</span><span class="n">sparea_b</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="n">readable_block_addr</span><span class="p">[</span><span class="n">x_addr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mh">0x840</span> <span class="o">*</span> <span class="mh">0x800</span><span class="p">),</span> <span class="n">get_le_int16</span><span class="p">(</span><span class="n">sparea_b</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">pbuffer</span> <span class="o">=</span> <span class="n">page_a</span> <span class="o">+</span> <span class="n">page_b</span> <span class="o">+</span> <span class="n">page_c</span>
</span></span><span class="line"><span class="cl">                    <span class="n">raw_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pbuffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">sp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sparea_b</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">raw_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">sp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">readable_block_addr_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">readable_block_addr</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">raw_file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">raw_file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">rawbin</span> <span class="o">=</span> <span class="n">raw_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">raw_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">cur_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">nanddisk_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">nand_file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">readable_block_addr_sorted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">k</span><span class="o">&lt;</span><span class="mh">0xfff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;fix block </span><span class="si">{:x}</span><span class="s2">, off </span><span class="si">{:x}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># print(hex(k))</span>
</span></span><span class="line"><span class="cl">                <span class="n">skip</span> <span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="n">cur_index</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">nand_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rawbin</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mh">0x20000</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur_index</span> <span class="o">=</span> <span class="n">cur_index</span> <span class="o">+</span> <span class="n">skip</span>
</span></span><span class="line"><span class="cl">        <span class="n">nand_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>Ultimately, I successfully reconstructed the firmware. Given the bit-flip characteristics of NAND flash, I applied Hamming ECC for error correction. Since the system had undergone many reboot cycles, some data remained inconsistent, resulting in the significant differences shown in the comparison below.</p>
<p><img loading="lazy"  src="./fixed_diff.png"
        alt="fixed_diff"/></p>
<p>The file sizes and types were correct.</p>
<p><img loading="lazy"  src="./fdisk.png"
        alt="fdisk"/></p>
<p>The size of the reconstructed firmware matched the 496.6MiB reported by the live system.</p>
<p><img loading="lazy"  src="./nand_info.png"
        alt="nand_info"/></p>
<p>Upon mounting the second partition, the directory structure was displayed correctly.</p>
<p><img loading="lazy"  src="./fixed.png"
        alt="fixed"/></p>
<p>However, some files were likely corrupted due to uncorrectable bit flips. Due to time constraints, I did not pursue further analysis.</p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/nand/>NAND</a><a class="tag" href=/en/tags/ftl/>FTL</a><a class="tag" href=/en/tags/oob/>OOB</a><a class="tag" href=/en/tags/flash/>Flash</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/firmware-extraction-series-sata-hdd-unlock/"><span class="iconfont icon-article"></span>Firmware Extraction Series - SATA HDD Unlock</a></p><p><a class="link" href="/en/posts/visteon-firmware-repacking/"><span class="iconfont icon-article"></span>Visteon Firmware Repacking</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>