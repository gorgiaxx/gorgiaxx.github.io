<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Introduction to FlashROM
It‚Äôs been more than half a year since my last post. The firmware extraction series has already reached Part 11. This one isn‚Äôt particularly hard in my opinion, so I can publish it openly."><title>Firmware Extraction Series: Reading Flash with flashrom&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series: Reading Flash with flashrom" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-read-flash-with-flashrom/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series: Reading Flash with flashrom</h1><p class="article date">Saturday, July 20, 2019<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-read-flash-with-flashrom/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="introduction-to-flashrom">Introduction to FlashROM</h2>
<p>It‚Äôs been more than half a year since my last post. The firmware extraction series has already reached Part 11. This one isn‚Äôt particularly hard in my opinion, so I can publish it openly.</p>
<p>Flashrom is an open-source project for extracting (and programming) flash firmware. It supports multiple hardware platforms, SPI flash, and parallel flash.</p>
<p>This time I ran into a <strong>NAND SPI flash</strong>: <strong>IS38SML01G1</strong>, an automotive-grade storage chip. At first I assumed ‚ÄúSPI flash‚Äù always meant NOR, so I didn‚Äôt read the datasheet and tried to wire it up and read it with a typical programmer. Most common programmers couldn‚Äôt read it; I also tried an RT809H and failed. After checking the datasheet, I realized it was NAND flash. At the time, only <a href="https://www.reveltronics.com/en/products/revelprog-is-serial-memory-programmer-usb"target="_blank" rel="noopener noreferrer">REVELPROG-IS</a> supported read/write for it.</p>
<p>Initially I wanted to use an FT2232HL, but found the official documentation/support for that chip not great, so I ended up using a Raspberry Pi 3B.</p>
<p>The <code>flashchips.c</code> file stores configuration information for various chips‚Äîvery well designed and highly extensible.</p>
<pre tabindex="0"><code>{
    .vendor		= Vendor name
    .name		= Chip name
    .bustype		= Supported flash bus types (Parallel, LPC...)
    .manufacture_id	= Manufacturer chip ID
    .model_id		= Model chip ID
    .total_size		= Total size in (binary) kbytes
    .page_size		= Page or eraseblock(?) size in bytes
    .tested		= Test status
    .probe		= Probe function
    .probe_timing	= Probe function delay
    .block_erasers[]	= Array of erase layouts and erase functions
    {
        .eraseblocks[]	= Array of { blocksize, blockcount }
        .block_erase	= Block erase function
    }
    .printlock		= Chip lock status function
    .unlock		= Chip unlock function
    .write		= Chip write function
    .read		= Chip read function
    .voltage		= Voltage range in millivolt
}
</code></pre><p>Based on the datasheet, I added configuration for the 38SM device.
From the datasheet: a NAND SPI flash has <strong>1024 blocks</strong>, each block has <strong>64 pages</strong>, and each page is <strong>2K + 64 bytes</strong>, where the 64 bytes are the spare area.
<code>total_size</code> is in KB, so there‚Äôs no need to include the spare area in the size. The voltage range is set to 2.7V‚Äì3.6V per the datasheet.</p>
<pre tabindex="0"><code>{
	.vendor		= &#34;ISSI&#34;,
	.name		= &#34;IS38SML01G1&#34;,
	.bustype	= BUS_SPI,
	.manufacture_id	= ISSI_NAND_ID,
	.model_id	= ISSI_NAND_ID_SPI,
	.total_size	= 131072, /* kb */
	.page_size	= 2048, /* bytes, actual page size is 64 */
	.tested		= {.probe = OK, .read = OK, .erase = NA, .write = NA},
	.probe		= probe_spi_rdid5,
	.probe_timing	= TIMING_ZERO,
	.block_erasers	=
	{
		{
			.eraseblocks = { {64 * 2048, 1024} },
			.block_erase = spi_block_erase_d8,
		}
	},
	.write		= NULL,
	.read		= spi_read_issi,
	.voltage	= {2700, 3600},
},
</code></pre><p>To read the flash contents, you need to implement chip initialization and read functionality. So we only need to provide pointers for <code>probe</code> and <code>read</code>. The figure below shows the command definitions, including the opcode byte, address bytes, dummy bytes, and the data bytes returned by the device. Data is transferred MSB-first.</p>
<p><img loading="lazy"  src="command_set.png"
        alt="command_set"/></p>
<p>Initialization needs to read the ID, so first define the chip IDs. The Mark Code and Device Code are useful. I also added the Communication Code <code>0x7F7F7F</code> while I was at it.</p>
<p><img loading="lazy"  src="jedec_id.png"
        alt="jedec_id"/></p>
<pre tabindex="0"><code>#define ISSI_NAND_ID		0xC8
#define ISSI_NAND_ID_SPI	0x21
#define ISSI_38SML01G1		0x7F7F7F
</code></pre><p>Flashrom‚Äôs built-in <code>probe_spi_rdid4</code> reads the JEDEC ID by sending <code>0x9F</code>, but this chip requires one dummy byte when sending the Read ID command. If you use the normal <code>probe_spi_rdid</code>, the first byte you read becomes <code>0x00</code>. The timing diagram quality in the ISSI datasheet is extremely low.</p>
<p><img loading="lazy"  src="read_id_timing.png"
        alt="read_id_timing"/></p>
<p>So we need a new function, named <code>probe_spi_rdid5</code>. We also add a read function <code>spi_read_issi</code>. Both need to be declared in <code>chipdrivers.h</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">probe_spi_rdid5</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">spi_read_issi</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span></span></code></pre></div><p>For the Read ID function: if the first byte is <code>0x00</code>, skip it and continue. Alternatively, you can include a dummy byte when sending the ID command, avoiding the need to check MISO data.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">probe_spi_rdid5</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="k">struct</span> <span class="n">flashchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">flash</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">id1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">id2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">spi_rdid</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="n">readarr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">oddparity</span><span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;RDID byte 0 parity violation. &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Check if this is a continuation vendor ID.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * FIXME: Handle continuation device IDs.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">oddparity</span><span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">			<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;RDID byte 1 parity violation. &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">id1</span> <span class="o">=</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">id2</span> <span class="o">=</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">id1</span> <span class="o">=</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">id2</span> <span class="o">=</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;%s: id1 0x%02x, id2 0x%02x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">id2</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">model_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Test if this is a pure vendor match. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">GENERIC_DEVICE_ID</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">model_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Test if there is any vendor ID. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">GENERIC_MANUF_ID</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">id1</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">id1</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Next is the read function. First, you need to understand the chip‚Äôs read flow: the NAND controller first loads NAND data into the <strong>cache memory</strong> (one page at a time), then reads data out from the cache and outputs it to the host.</p>
<p><img loading="lazy"  src="blockdiagram.png"
        alt="blockdiagram"/></p>
<p>So you must first send a page-read command and tell the controller which page to read. While NAND data is being transferred into the cache, you must not perform other read/write operations. At this time, the status register should indicate busy, i.e. OIP == 1.</p>
<p>After sending the page-read command, you should poll by sending <code>0x0F 0xC0</code> in a loop until OIP == 0.</p>
<p><img loading="lazy"  src="status_register.png"
        alt="status_register"/></p>
<p>So a complete read sequence is:</p>
<p>0x13 page read<br>
0x0F 0xC0 status polling<br>
0x03 cache read</p>
<p>According to the command definition, page-read uses 3 address bytes, where 1 byte is dummy, so the maximum address is 0xFFFF (65536 in decimal). 1024 blocks * 64 pages = 65536 pages. Here I temporarily interpret the dummy byte as [7:0], and the address as [23:8].</p>
<p><img loading="lazy"  src="page_read.png"
        alt="page_read"/></p>
<p>For cache read, the address length is 2 bytes, plus 1 byte + 4 bits of dummy cycles, so the cache addressing is 12 bits (4096). The datasheet-defined range is 0‚Äì2112, which you can interpret as 2048 bytes + 64 bytes (OOB area).</p>
<p><img loading="lazy"  src="page_cache_read.png"
        alt="page_cache_read"/></p>
<p>Below is the implementation of <code>spi_read_issi</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">spi_read_issi</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">page_read_resp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">get_feature_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">address_h</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">address_h</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">address_l</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">address_l</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span> <span class="cm">/* page read cmd */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* dummy byte */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">address_h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">address_l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">page_read_resp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* 7-0 bits: ECC_S1, ECC_S0, P_Fail, E_Fail, WEL3, OIP */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">uint8_t</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">get_feature_ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">internal_sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">get_feature_ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">get_feature_cmd</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">get_feature_cmd</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">get_feature_ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* printf(&#34;\nStatus: 0x%X, get_feature_ret:%d\n&#34;, (unsigned int)status[0], get_feature_ret); */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* page read cmd */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* dummy byte */</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="kt">int</span> <span class="n">cache_read_ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_read_cmd</span><span class="p">),</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">cache_read_cmd</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">2048</span> <span class="o">*</span> <span class="n">buf_off</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_read_ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;device busy. timeout</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">get_feature_cmd</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">get_feature_cmd</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* Send Read */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">2048</span> <span class="o">*</span> <span class="n">buf_off</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;buf_off:%d, address: 0x%x%x</span><span class="se">\n</span><span class="s">buf_addr: 0x%X</span><span class="se">\n</span><span class="s">data:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf_off</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">buf_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/*int* = 4* int8 */</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%08x&#34;</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// printf(&#34;\n&#34;);
</span></span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;reading err&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">buf_off</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="fly-wiring">Fly-wiring</h2>
<p>First, use a clip fixture. Heat with a hot-air gun at 400¬∞C, preheating from the bottom for 12 seconds.</p>
<p><img loading="lazy"  src="target_device.jpg"
        alt="target_device"/></p>
<p>Solder the chip onto an adapter board.</p>
<p><img loading="lazy"  src="sop8.jpg"
        alt="sop8"/></p>
<p>At first I didn‚Äôt consider that the bottom of the WSON package could cause shorts, so I reworked the fly-wires.</p>
<p><img loading="lazy"  src="wson8.png"
        alt="wson8"/></p>
<p><img loading="lazy"  src="jumping1.jpg"
        alt="jumping1"/></p>
<p><img loading="lazy"  src="jumping2.jpg"
        alt="jumping2"/></p>
<p>Connect to a Raspberry Pi 3B.
<img loading="lazy"  src="reading_by_rpi.jpg"
        alt="reading_by_rpi"/></p>
<p>Wiring is as follows. HOLD should be tied to VCC.</p>
<table>
  <thead>
      <tr>
          <th>RPi header</th>
          <th>SPI flash</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>25</td>
          <td>GND</td>
      </tr>
      <tr>
          <td>24</td>
          <td>/CS</td>
      </tr>
      <tr>
          <td>23</td>
          <td>SCK</td>
      </tr>
      <tr>
          <td>21</td>
          <td>DO</td>
      </tr>
      <tr>
          <td>19</td>
          <td>DI</td>
      </tr>
      <tr>
          <td>17</td>
          <td>VCC 3.3V (+ /HOLD, /WP)</td>
      </tr>
  </tbody>
</table>
<p>Enable SPI.</p>
<pre tabindex="0"><code>vi /boot/config.txt
dtparam=spi=on
</code></pre><p>Load kernel modules.</p>
<pre tabindex="0"><code># If that fails you may wanna try the older spi_bcm2708 module instead
sudo modprobe spi_bcm2835
sudo modprobe spidev
</code></pre><pre tabindex="0"><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=10000 -c IS38SML01G1 -V -r /tmp/is38_nooob.bin
</code></pre><p><img loading="lazy"  src="reading.png"
        alt="reading"/></p>
<h2 id="target-device-initialization-analysis">Target Device Initialization Analysis</h2>
<p>The 128MB dump was almost entirely <code>0xFF</code>. But after asking the vendor, they confirmed this chip stores some software and configuration data. The ISSI flash datasheet didn‚Äôt clearly document the address format for page reads. The address is 3 bytes; the high and low bytes are consecutive, so there are two permutations. Combined with the dummy byte, there are four possible address formats, and I couldn‚Äôt tell which one was correct. I dumped all four variants; only the distribution changed, and there was still no way to confirm the correct mapping.</p>
<p><img loading="lazy"  src="flashdump1.png"
        alt="flashdump1"/>
<img loading="lazy"  src="flashdump2.png"
        alt="flashdump2"/>
<img loading="lazy"  src="flashdump3.png"
        alt="flashdump3"/>
<img loading="lazy"  src="flashdump4.png"
        alt="flashdump4"/></p>
<p>With a driver implemented strictly according to the datasheet, the dump still came out almost entirely <code>0xFF</code>, so I suspected something was wrong and brought in a logic analyzer.
You only need to capture three channels: MOSI, MISO, CLK. Use MSB; set CPOL and CPHA to 0.</p>
<p><img loading="lazy"  src="spi_mode.png"
        alt="spi_mode"/>
<img loading="lazy"  src="kingst_spiconf.png"
        alt="kingst_spiconf"/></p>
<p>Trigger on the rising edge; set sampling rate to 200MHz.
First, I captured the SPI traffic when the Raspberry Pi was reading the flash. It matched the datasheet.</p>
<p>Read JEDEC ID:</p>
<p><img loading="lazy"  src="rpi_spi_init.png"
        alt="rpi_spi_init"/></p>
<p>Read status:</p>
<p><img loading="lazy"  src="rpi_status.png"
        alt="rpi_status"/></p>
<p>When reading cache, after sending 4 bytes, MISO stayed high the whole time, which made it feel like something was off.</p>
<p><img loading="lazy"  src="rpi_spi_read_cache.png"
        alt="rpi_spi_read_cache"/></p>
<p>Then I captured traffic from the target device.</p>
<p><img loading="lazy"  src="logical_analyzer_probe.jpg"
        alt="logical_analyzer_probe"/></p>
<p>First, reading the JEDEC ID was fine. Compared to the Raspberry Pi, the target device only returned the first two ID bytes.</p>
<p><img loading="lazy"  src="target_init.png"
        alt="target_init"/></p>
<p>From page read to cache read: it sends the page-read command, then reads status, waits for the controller to return 0, then sends the cache-read command. This is where things went wrong. MISO still output <code>0xFF</code>, but in 4-byte chunks; after each 4-byte output, the master would ‚Äúreceive‚Äù 4 bytes of unknown meaning, alternating in a loop. <code>0x03</code> is confirmed to be single-lane transfer, and on the Raspberry Pi, MOSI wouldn‚Äôt generate any data during this phase, which suggests those bytes weren‚Äôt coming from the slave.</p>
<p><img loading="lazy"  src="target_reading.png"
        alt="target_reading"/></p>
<p>At least this suggests my code wasn‚Äôt the issue‚Äîrather, the device wasn‚Äôt actually using this storage chip at the moment.</p>
<h2 id="consequences-of-reading-the-oob">Consequences of Reading the OOB</h2>
<p>At first I tried to dump the spare area as well, so I set the response buffer to 2112 bytes. In the dump file, I saw an ELF header, and initially thought the target device used ELF binaries. But something felt off‚Äîwhy would an automotive gateway run Linux?</p>
<p><img loading="lazy"  src="dump1.png"
        alt="dump1"/></p>
<p>Later, after checking the memory address layout, it looked like I exceeded the heap size and did an out-of-bounds read into subsequent library data.</p>
<p><img loading="lazy"  src="maps.png"
        alt="maps"/></p>
<p>If you do the math: the first segment is the actual heap size, the second is the actual read size, and the third is the normal read size‚Äîso don‚Äôt read the spare area.</p>
<p><img loading="lazy"  src="address_calc.png"
        alt="address_calc"/></p>
<h2 id="revelprog-is-unboxing">REVELPROG-IS Unboxing</h2>
<p>More than a month later, I bought a REVELPROG-IS to verify whether flashrom‚Äôs read results were correct.</p>
<p><img loading="lazy"  src="package.jpg"
        alt="package"/></p>
<p>Made in Poland. The packaging and programmer look decent.</p>
<p><img loading="lazy"  src="revelprog.jpg"
        alt="revelprog"/></p>
<p>The circuit design is simple: one STM32F103. It‚Äôs a bit pricey, but at least it hasn‚Äôt been cloned aggressively.</p>
<p><img loading="lazy"  src="STM32F103.jpg"
        alt="STM32F103"/></p>
<h2 id="verifying-the-dump">Verifying the Dump</h2>
<p>The WSON8 socket hadn‚Äôt arrived yet, so I temporarily used fly-wires.</p>
<p><img loading="lazy"  src="reading_with_prog.jpg"
        alt="reading_with_prog"/></p>
<p>The read speed was extremely slow and took a few minutes. It doesn‚Äôt support speed adjustment‚Äîflashrom is still the fastest.</p>
<p><img loading="lazy"  src="reading_with_prog2.png"
        alt="reading_with_prog2"/></p>
<p>The data read was consistent with the earlier dump.</p>
<p><img loading="lazy"  src="result.png"
        alt="result"/></p>
<p>The address format matches the third variant. I forgot the exact ordering, but I‚Äôll use this programmer for future dumps.</p>
<p><img loading="lazy"  src="flashdump5.png"
        alt="flashdump5"/></p>
<h2 id="errata">Errata</h2>
<p>In later research, I found a few pitfalls in this post.
<code>address_h</code> and <code>address_l</code> were assumptions made without knowing the actual addressing rules, because the datasheet didn‚Äôt document them. I assumed both were 8-bit.
After reading datasheets for several other chips, I confirmed this was problematic.</p>
<p><img loading="lazy"  src="readpage_address.png"
        alt="readpage_address"/></p>
<p>In reality, these two parameters represent the <strong>block address</strong> and <strong>page address</strong>. The device has 1024 blocks (10 bits) and 64 pages per block (6 bits), totaling exactly 16 bits. Different chip capacities follow different rules.</p>
<p>So the read results can contain repeats. Also, since the valid data happened to be distributed near the beginning of the storage and the rest was invalid, the final result still looked consistent with the programmer‚Äôs dump‚Äîeven with a wrong address interpretation.</p>
<p>Additionally, the <code>status</code> check in the sample code is not strictly correct: status doesn‚Äôt have to be 0 for reads to work. BBM LUT FULL (Look-Up Table) may also be 1, and ECC Err Status can be 0x20.</p>
<p><img loading="lazy"  src="status.png"
        alt="status"/></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/flashrom/>FlashROM</a><a class="tag" href=/en/tags/nand/>NAND</a><a class="tag" href=/en/tags/raspberry-pi/>Raspberry Pi</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/4g-modem-attack-scenarios-in-vehicle-networking/"><span class="iconfont icon-article"></span>Overview of 4G Modem Attack Scenarios in Vehicle Networking</a></p><p><a class="link" href="/en/posts/firmware-extraction-series-sata-hdd-unlock/"><span class="iconfont icon-article"></span>Firmware Extraction Series - SATA HDD Unlock</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>