<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Introduction to FlashROM
It‚Äôs been over six months since my last post. The firmware extraction series has now reached Part 11. In my opinion, this topic isn&rsquo;t particularly sensitive, so I&rsquo;m sharing it openly."><title>Firmware Extraction Series: Reading Flash with flashrom&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Firmware Extraction Series: Reading Flash with flashrom" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/firmware-extraction-series-read-flash-with-flashrom/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><style>
     
    .toc-wrapper {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 9999;
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 10px;
    }

     
    .toc-button {
        background-color: #fff;
        color: #333;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid #ddd;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .toc-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .toc-button svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }

     
    .toc-content-box {
        background: #fff;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 15px;
        width: 250px;
        max-height: 60vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        display: none;
         
        font-size: 0.9em;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.3s, transform 0.3s;
    }

    .toc-content-box.show {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }

    .toc-header {
        font-weight: bold;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 8px;
        margin-bottom: 8px;
        font-size: 1.1em;
    }

     
    #TableOfContents {
        text-align: left;
    }

    #TableOfContents ul,
    #TableOfContents ol {
        list-style: none;
        padding-left: 0;
        margin: 0;
    }

    #TableOfContents li {
        margin: 4px 0;
    }

    #TableOfContents ul ul,
    #TableOfContents ol ol {
        padding-left: 1em;
    }

    #TableOfContents a {
        text-decoration: none;
        color: #555;
        display: block;
        padding: 2px 0;
        transition: color 0.2s;
    }

    #TableOfContents a:hover {
        color: #007bff;
    }

     
    @media (prefers-color-scheme: dark) {
        .toc-button {
            background-color: #333;
            color: #ddd;
            border-color: #555;
        }

        .toc-content-box {
            background-color: #2a2a2a;
            border-color: #444;
            color: #ddd;
        }

        .toc-header {
            border-bottom-color: #444;
        }

        #TableOfContents a {
            color: #aaa;
        }

        #TableOfContents a:hover {
            color: #fff;
        }
    }
</style><div class="article-container"><section class="article header">
    <h1 class="article title">Firmware Extraction Series: Reading Flash with flashrom</h1><p class="article date">Saturday, July 20, 2019<span class="langs"><span class="lang">
                    <a href="/zh/posts/firmware-extraction-series-read-flash-with-flashrom/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="introduction-to-flashrom">Introduction to FlashROM</h2>
<p>It‚Äôs been over six months since my last post. The firmware extraction series has now reached Part 11. In my opinion, this topic isn&rsquo;t particularly sensitive, so I&rsquo;m sharing it openly.</p>
<p>Flashrom is an open-source project designed for extracting (and programming) flash firmware. It supports multiple hardware platforms, as well as SPI and parallel flash interfaces.</p>
<p>I recently encountered a <strong>NAND SPI flash</strong> chip: the <strong>IS38SML01G1</strong>, an automotive-grade storage device. Initially, I assumed ‚ÄúSPI flash‚Äù implied NOR flash, so I attempted to wire it up and read it with a standard programmer without checking the datasheet. Most standard programmers were unable to read it; even the RT809H failed. After reviewing the datasheet, I realized it was NAND flash. At the time, only the <a href="https://www.reveltronics.com/en/products/revelprog-is-serial-memory-programmer-usb"target="_blank" rel="noopener noreferrer">REVELPROG-IS</a> supported reading and writing for this chip.</p>
<p>I initially intended to use an FT2232HL, but due to poor official documentation and support, I opted for a Raspberry Pi 3B instead.</p>
<p>The <code>flashchips.c</code> file stores configuration information for various chips‚Äîit is well-designed and highly extensible.</p>
<pre tabindex="0"><code>{
    .vendor		= Vendor name
    .name		= Chip name
    .bustype		= Supported flash bus types (Parallel, LPC...)
    .manufacture_id	= Manufacturer chip ID
    .model_id		= Model chip ID
    .total_size		= Total size in (binary) kbytes
    .page_size		= Page or eraseblock(?) size in bytes
    .tested		= Test status
    .probe		= Probe function
    .probe_timing	= Probe function delay
    .block_erasers[]	= Array of erase layouts and erase functions
    {
        .eraseblocks[]	= Array of { blocksize, blockcount }
        .block_erase	= Block erase function
    }
    .printlock		= Chip lock status function
    .unlock		= Chip unlock function
    .write		= Chip write function
    .read		= Chip read function
    .voltage		= Voltage range in millivolt
}
</code></pre><p>Based on the datasheet, I added the configuration for the 38SM device.
According to the datasheet, this NAND SPI flash has <strong>1024 blocks</strong>, with each block containing <strong>64 pages</strong>. Each page consists of <strong>2K + 64 bytes</strong>, where the 64 bytes are reserved for the spare (OOB) area.
<code>total_size</code> is specified in KB, so the spare area is excluded from this value. The voltage range is set to 2.7V‚Äì3.6V, as per the datasheet.</p>
<pre tabindex="0"><code>{
	.vendor		= &#34;ISSI&#34;,
	.name		= &#34;IS38SML01G1&#34;,
	.bustype	= BUS_SPI,
	.manufacture_id	= ISSI_NAND_ID,
	.model_id	= ISSI_NAND_ID_SPI,
	.total_size	= 131072, /* kb */
	.page_size	= 2048, /* bytes, actual page size is 64 */
	.tested		= {.probe = OK, .read = OK, .erase = NA, .write = NA},
	.probe		= probe_spi_rdid5,
	.probe_timing	= TIMING_ZERO,
	.block_erasers	=
	{
		{
			.eraseblocks = { {64 * 2048, 1024} },
			.block_erase = spi_block_erase_d8,
		}
	},
	.write		= NULL,
	.read		= spi_read_issi,
	.voltage	= {2700, 3600},
},
</code></pre><p>Reading flash contents requires implementing chip initialization and read functionality. Therefore, we only need to define the <code>probe</code> and <code>read</code> function pointers. The figure below illustrates the command definitions, including the opcode byte, address bytes, dummy bytes, and the data bytes returned by the device. Data is transferred MSB-first.</p>
<p><img loading="lazy"  src="command_set.png"
        alt="command_set"/></p>
<p>Initialization requires reading the chip ID, so we must first define the IDs. The Mark Code and Device Code are useful identifiers. I also added the Communication Code <code>0x7F7F7F</code> for completeness.</p>
<p><img loading="lazy"  src="jedec_id.png"
        alt="jedec_id"/></p>
<pre tabindex="0"><code>#define ISSI_NAND_ID		0xC8
#define ISSI_NAND_ID_SPI	0x21
#define ISSI_38SML01G1		0x7F7F7F
</code></pre><p>Flashrom‚Äôs built-in <code>probe_spi_rdid4</code> reads the JEDEC ID by sending <code>0x9F</code>. However, this chip requires a single dummy byte when sending the Read ID command. Consequently, using the standard <code>probe_spi_rdid</code> results in the first read byte being <code>0x00</code>. The timing diagram provided in the ISSI datasheet is of extremely low quality.</p>
<p><img loading="lazy"  src="read_id_timing.png"
        alt="read_id_timing"/></p>
<p>Thus, a new function is required, which I named <code>probe_spi_rdid5</code>. I also added a read function, <code>spi_read_issi</code>. Both must be declared in <code>chipdrivers.h</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">probe_spi_rdid5</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">spi_read_issi</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span></span></code></pre></div><p>For the Read ID function: if the first byte is <code>0x00</code>, it should be skipped. Alternatively, a dummy byte can be included when sending the ID command, which avoids the need to check the MISO data for padding.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">probe_spi_rdid5</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="k">struct</span> <span class="n">flashchip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">flash</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">id1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">id2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">spi_rdid</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="n">readarr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">oddparity</span><span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">		<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;RDID byte 0 parity violation. &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Check if this is a continuation vendor ID.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 * FIXME: Handle continuation device IDs.
</span></span></span><span class="line"><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">oddparity</span><span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">			<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;RDID byte 1 parity violation. &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">id1</span> <span class="o">=</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">id2</span> <span class="o">=</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">id1</span> <span class="o">=</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">id2</span> <span class="o">=</span> <span class="p">(</span><span class="n">readarr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">readarr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">msg_cdbg</span><span class="p">(</span><span class="s">&#34;%s: id1 0x%02x, id2 0x%02x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">id2</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">model_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Test if this is a pure vendor match. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">id1</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">GENERIC_DEVICE_ID</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">model_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Test if there is any vendor ID. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">GENERIC_MANUF_ID</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">manufacture_id</span> <span class="o">&amp;&amp;</span> <span class="n">id1</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">id1</span> <span class="o">!=</span> <span class="mh">0x00</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Next is the read function. It is important to first understand the chip‚Äôs read flow: the NAND controller loads NAND data into <strong>cache memory</strong> (one page at a time) before reading it out from the cache to output to the host.</p>
<p><img loading="lazy"  src="blockdiagram.png"
        alt="blockdiagram"/></p>
<p>Therefore, a page-read command must first be sent to instruct the controller which page to read. While data is being transferred into the cache, no other read/write operations should be performed. During this process, the status register will indicate a busy state (i.e., OIP == 1).</p>
<p>After sending the page-read command, the status must be polled by repeatedly sending <code>0x0F 0xC0</code> until OIP == 0.</p>
<p><img loading="lazy"  src="status_register.png"
        alt="status_register"/></p>
<p>The complete read sequence is as follows:</p>
<p>0x13 page read<br>
0x0F 0xC0 status polling<br>
0x03 cache read</p>
<p>According to the command definition, the page-read command uses 3 address bytes, one of which is a dummy byte. This allows for a maximum address of 0xFFFF (65536 in decimal). 1024 blocks * 64 pages equals 65536 pages. Here, I temporarily interpret the dummy byte as [7:0] and the address as [23:8].</p>
<p><img loading="lazy"  src="page_read.png"
        alt="page_read"/></p>
<p>For the cache read, the address length is 2 bytes, plus 1 byte + 4 bits of dummy cycles, resulting in a cache addressing range of 12 bits (4096). The datasheet states the range is 0‚Äì2112, corresponding to 2048 bytes (data) + 64 bytes (OOB area).</p>
<p><img loading="lazy"  src="page_cache_read.png"
        alt="page_cache_read"/></p>
<p>The implementation of <code>spi_read_issi</code> is provided below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">spi_read_issi</span><span class="p">(</span><span class="k">struct</span> <span class="n">flashctx</span> <span class="o">*</span><span class="n">flash</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">page_read_resp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buf_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">get_feature_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">address_h</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">address_h</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">address_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">address_l</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">address_l</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span> <span class="cm">/* page read cmd */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* dummy byte */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">address_h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">address_l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">page_read_resp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* 7-0 bits: ECC_S1, ECC_S0, P_Fail, E_Fail, WEL3, OIP */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">uint8_t</span> <span class="n">status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">get_feature_ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">internal_sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">get_feature_ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">get_feature_cmd</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">get_feature_cmd</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">get_feature_ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* printf(&#34;\nStatus: 0x%X, get_feature_ret:%d\n&#34;, (unsigned int)status[0], get_feature_ret); */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="cm">/* page read cmd */</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cache_read_cmd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span> <span class="cm">/* dummy byte */</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="kt">int</span> <span class="n">cache_read_ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_read_cmd</span><span class="p">),</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">cache_read_cmd</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">2048</span> <span class="o">*</span> <span class="n">buf_off</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_read_ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;device busy. timeout</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">ret</span> <span class="o">=</span> <span class="nf">spi_send_command</span><span class="p">(</span><span class="n">flash</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">get_feature_cmd</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">get_feature_cmd</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* Send Read */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">2048</span> <span class="o">*</span> <span class="n">buf_off</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">buf_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xffffffff</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;buf_off:%d, address: 0x%x%x</span><span class="se">\n</span><span class="s">buf_addr: 0x%X</span><span class="se">\n</span><span class="s">data:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf_off</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">buf_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="cm">/*int* = 4* int8 */</span>
</span></span><span class="line"><span class="cl">				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%08x&#34;</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">[</span><span class="n">b</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// printf(&#34;\n&#34;);
</span></span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;reading err&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">buf_off</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="fly-wiring">Fly-wiring</h2>
<p>First, I secured the chip using a clip fixture and applied heat with a hot-air gun at 400¬∞C, preheating from the bottom for 12 seconds.</p>
<p><img loading="lazy"  src="target_device.jpg"
        alt="target_device"/></p>
<p>I then soldered the chip onto an adapter board.</p>
<p><img loading="lazy"  src="sop8.jpg"
        alt="sop8"/></p>
<p>Initially, I overlooked the potential for shorts on the underside of the WSON package, which required me to rework the fly-wires.</p>
<p><img loading="lazy"  src="wson8.png"
        alt="wson8"/></p>
<p><img loading="lazy"  src="jumping1.jpg"
        alt="jumping1"/></p>
<p><img loading="lazy"  src="jumping2.jpg"
        alt="jumping2"/></p>
<p>I connected it to a Raspberry Pi 3B.
<img loading="lazy"  src="reading_by_rpi.jpg"
        alt="reading_by_rpi"/></p>
<p>The wiring configuration is as follows. Note that HOLD should be tied to VCC.</p>
<table>
  <thead>
      <tr>
          <th>RPi header</th>
          <th>SPI flash</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>25</td>
          <td>GND</td>
      </tr>
      <tr>
          <td>24</td>
          <td>/CS</td>
      </tr>
      <tr>
          <td>23</td>
          <td>SCK</td>
      </tr>
      <tr>
          <td>21</td>
          <td>DO</td>
      </tr>
      <tr>
          <td>19</td>
          <td>DI</td>
      </tr>
      <tr>
          <td>17</td>
          <td>VCC 3.3V (+ /HOLD, /WP)</td>
      </tr>
  </tbody>
</table>
<p>Enable SPI.</p>
<pre tabindex="0"><code>vi /boot/config.txt
dtparam=spi=on
</code></pre><p>Load kernel modules.</p>
<pre tabindex="0"><code># If that fails you may wanna try the older spi_bcm2708 module instead
sudo modprobe spi_bcm2835
sudo modprobe spidev
</code></pre><pre tabindex="0"><code>flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=10000 -c IS38SML01G1 -V -r /tmp/is38_nooob.bin
</code></pre><p><img loading="lazy"  src="reading.png"
        alt="reading"/></p>
<h2 id="target-device-initialization-analysis">Target Device Initialization Analysis</h2>
<h2 id="target-device-initialization-analysis-1">Target Device Initialization Analysis</h2>
<p>The extracted 128MB dump consisted almost entirely of <code>0xFF</code>. However, the vendor confirmed that the chip should contain software and configuration data. The ISSI flash datasheet lacked clear documentation regarding the address format for page reads. Since the address consists of 3 bytes, and the high/low bytes are consecutive, there are two permutations. Combined with the dummy byte, this results in four possible address modes. I was unable to determine the correct one. I dumped all four variants; while the data distribution changed, I could not confirm the correct mapping.</p>
<p><img loading="lazy"  src="flashdump1.png"
        alt="flashdump1"/>
<img loading="lazy"  src="flashdump2.png"
        alt="flashdump2"/>
<img loading="lazy"  src="flashdump3.png"
        alt="flashdump3"/>
<img loading="lazy"  src="flashdump4.png"
        alt="flashdump4"/></p>
<p>Even with a driver implemented strictly according to the datasheet, the dump was predominantly <code>0xFF</code>. Suspecting an issue, I used a logic analyzer to investigate.
You only need to capture three channels: MOSI, MISO, CLK. Use MSB; set CPOL and CPHA to 0.</p>
<p><img loading="lazy"  src="spi_mode.png"
        alt="spi_mode"/>
<img loading="lazy"  src="kingst_spiconf.png"
        alt="kingst_spiconf"/></p>
<p>Triggering on the rising edge with a sampling rate of 200MHz, I first captured the SPI traffic during the Raspberry Pi&rsquo;s read operation. It matched the datasheet.</p>
<p>Read JEDEC ID:</p>
<p><img loading="lazy"  src="rpi_spi_init.png"
        alt="rpi_spi_init"/></p>
<p>Read status:</p>
<p><img loading="lazy"  src="rpi_status.png"
        alt="rpi_status"/></p>
<p>When reading the cache, after sending 4 bytes, MISO remained high throughout. This behavior seemed anomalous.</p>
<p><img loading="lazy"  src="rpi_spi_read_cache.png"
        alt="rpi_spi_read_cache"/></p>
<p>Then, I captured traffic from the target device.</p>
<p><img loading="lazy"  src="logical_analyzer_probe.jpg"
        alt="logical_analyzer_probe"/></p>
<p>The JEDEC ID read was normal. Unlike the Raspberry Pi, the target device only returned the first two bytes of the ID.</p>
<p><img loading="lazy"  src="target_init.png"
        alt="target_init"/></p>
<p>The sequence from page read to cache read involves sending the page-read command, reading the status, waiting for the controller to return 0, and then sending the cache-read command. This is where the discrepancy occurred. MISO still output <code>0xFF</code>, but in 4-byte chunks. After each 4-byte output, the master would ‚Äúreceive‚Äù 4 bytes of unknown data, alternating in a loop. Since <code>0x03</code> confirms a single-lane transfer, and the Raspberry Pi&rsquo;s MOSI line was idle during this phase, these bytes were likely not originating from the slave.</p>
<p><img loading="lazy"  src="target_reading.png"
        alt="target_reading"/></p>
<p>This suggested that my code wasn&rsquo;t the issue; rather, the device wasn&rsquo;t actively using this storage chip at that moment.</p>
<h2 id="consequences-of-reading-the-oob">Consequences of Reading the OOB</h2>
<h2 id="consequences-of-reading-the-oob-1">Consequences of Reading the OOB</h2>
<p>Initially, I attempted to dump the spare area as well by setting the response buffer to 2112 bytes. In the resulting dump file, I observed an ELF header, which led me to believe the target device ran ELF binaries. However, this seemed unusual‚Äîwhy would an automotive gateway run Linux?</p>
<p><img loading="lazy"  src="dump1.png"
        alt="dump1"/></p>
<p>Later, after checking the memory address layout, I realized I had exceeded the heap size and performed an out-of-bounds read into adjacent library data.</p>
<p><img loading="lazy"  src="maps.png"
        alt="maps"/></p>
<p>The math confirms this: the first segment is the actual heap size, the second is the actual read size, and the third is the normal read size. Therefore, one should not attempt to read the spare area in this context.</p>
<p><img loading="lazy"  src="address_calc.png"
        alt="address_calc"/></p>
<h2 id="revelprog-is-unboxing">REVELPROG-IS Unboxing</h2>
<p>Over a month later, I purchased a REVELPROG-IS to verify the accuracy of flashrom‚Äôs read results.</p>
<p><img loading="lazy"  src="package.jpg"
        alt="package"/></p>
<p>Made in Poland, the packaging and programmer appear to be of good quality.</p>
<p><img loading="lazy"  src="revelprog.jpg"
        alt="revelprog"/></p>
<p>The circuit design is simple, featuring a single STM32F103. While it is somewhat expensive, it at least hasn&rsquo;t been aggressively cloned.</p>
<p><img loading="lazy"  src="STM32F103.jpg"
        alt="STM32F103"/></p>
<h2 id="verifying-the-dump">Verifying the Dump</h2>
<p>Since the WSON8 socket hadn&rsquo;t arrived, I temporarily used fly-wires for the connection.</p>
<p><img loading="lazy"  src="reading_with_prog.jpg"
        alt="reading_with_prog"/></p>
<p>The read speed was extremely slow, taking several minutes. It does not support speed adjustment, making flashrom significantly faster.</p>
<p><img loading="lazy"  src="reading_with_prog2.png"
        alt="reading_with_prog2"/></p>
<p>The data read was consistent with the earlier dump.</p>
<p><img loading="lazy"  src="result.png"
        alt="result"/></p>
<p>The address format matches the third variant. Although I&rsquo;ve forgotten the exact ordering, I plan to use this programmer for future dumps.</p>
<p><img loading="lazy"  src="flashdump5.png"
        alt="flashdump5"/></p>
<h2 id="errata">Errata</h2>
<h2 id="errata-1">Errata</h2>
<p>In subsequent research, I identified a few pitfalls in this post.
<code>address_h</code> and <code>address_l</code> were assumptions made without knowledge of the actual addressing rules, as they were undocumented in the datasheet. I incorrectly assumed both were 8-bit.
After reviewing datasheets for several other chips, I confirmed this was an issue.</p>
<p><img loading="lazy"  src="readpage_address.png"
        alt="readpage_address"/></p>
<p>In reality, these two parameters represent the <strong>block address</strong> and <strong>page address</strong>. The device has 1024 blocks (10 bits) and 64 pages per block (6 bits), totaling exactly 16 bits. Different chip capacities follow different addressing rules.</p>
<p>Consequently, the read results can contain duplicated data. Furthermore, since the valid data was located near the beginning of the storage and the rest was irrelevant, the final result appeared consistent with the programmer‚Äôs dump‚Äîdespite the incorrect address interpretation.</p>
<p>Additionally, the <code>status</code> check in the sample code is not strictly correct: the status doesn&rsquo;t necessarily have to be 0 for reads to proceed. BBM LUT FULL (Look-Up Table) may also be 1, and ECC Err Status can be 0x20.</p>
<p><img loading="lazy"  src="status.png"
        alt="status"/></p>
</article><section class="article labels"><a class="category" href=/en/categories/firmware-extraction-series/>Firmware Extraction Series</a><a class="tag" href=/en/tags/flashrom/>FlashROM</a><a class="tag" href=/en/tags/nand/>NAND</a><a class="tag" href=/en/tags/raspberry-pi/>Raspberry Pi</a></section>
</div>

<div class="toc-wrapper">
    <div class="toc-content-box" id="toc-content-box">
        <div class="toc-header">Table of Contents</div>
        <nav id="TableOfContents">
  <ol>
    <li><a href="#introduction-to-flashrom">Introduction to FlashROM</a></li>
    <li><a href="#fly-wiring">Fly-wiring</a></li>
    <li><a href="#target-device-initialization-analysis">Target Device Initialization Analysis</a></li>
    <li><a href="#target-device-initialization-analysis-1">Target Device Initialization Analysis</a></li>
    <li><a href="#consequences-of-reading-the-oob">Consequences of Reading the OOB</a></li>
    <li><a href="#consequences-of-reading-the-oob-1">Consequences of Reading the OOB</a></li>
    <li><a href="#revelprog-is-unboxing">REVELPROG-IS Unboxing</a></li>
    <li><a href="#verifying-the-dump">Verifying the Dump</a></li>
    <li><a href="#errata">Errata</a></li>
    <li><a href="#errata-1">Errata</a></li>
  </ol>
</nav>
    </div>
    <div class="toc-button" onclick="toggleTOC()" title="">
        
        <svg viewBox="0 0 24 24">
            <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path>
        </svg>
    </div>
</div>

<script>
    function toggleTOC() {
        const tocBox = document.getElementById('toc-content-box');
        if (tocBox.classList.contains('show')) {
            tocBox.classList.remove('show');
            
            
            
            
            
            setTimeout(() => {
                tocBox.style.display = 'none';
            }, 300); 
        } else {
            tocBox.style.display = 'block';
            
            void tocBox.offsetWidth;
            tocBox.classList.add('show');
        }
    }

    
    document.addEventListener('click', function (event) {
        const wrapper = document.querySelector('.toc-wrapper');
        const tocBox = document.getElementById('toc-content-box');
        if (wrapper && !wrapper.contains(event.target) && tocBox.classList.contains('show')) {
            toggleTOC();
        }
    });
</script><div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/4g-modem-attack-scenarios-in-vehicle-networking/"><span class="iconfont icon-article"></span>Overview of 4G Modem Attack Scenarios in Vehicle Networking</a></p><p><a class="link" href="/en/posts/firmware-extraction-series-sata-hdd-unlock/"><span class="iconfont icon-article"></span>Firmware Extraction Series - SATA HDD Unlock</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>